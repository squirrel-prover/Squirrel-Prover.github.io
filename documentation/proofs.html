

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Proofs &mdash; Squirrel  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/ansi.css?v=e3444255" />
      <link rel="stylesheet" type="text/css" href="_static/notations.css?v=1a0322d9" />
      <link rel="stylesheet" type="text/css" href="_static/pre-text.css?v=ea32c3b7" />
      <link rel="stylesheet" type="text/css" href="_static/css/rtd_sphinx_search.min.css" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/notations.js?v=69751d6f"></script>
      <script src="_static/js/rtd_search_config.js"></script>
      <script src="_static/js/rtd_sphinx_search.min.js"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Commands" href="commands.html" />
    <link rel="prev" title="Declarations" href="declarations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Squirrel
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="reference-intro.html">Notations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="reference-intro.html#lexical-conventions">Lexical conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="reference-intro.html#infix-operators">Infix operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="logic.html">Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="logic.html#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#base-types">Base types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#type-variables-and-polymorphism">Type variables and polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#general-types">General types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#binders-and-tags">Binders and tags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#terms-with-binders">Terms with binders</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#multi-terms">Multi-terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#diff-terms">Diff-terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#macros">Macros</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#formulas">Formulas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#local-formulas">Local formulas</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#global-formulas">Global formulas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarations.html">Declarations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#names">Names</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#abstract-functions">Abstract functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#operators">Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#built-ins">Built-ins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#cryptographic-functions">Cryptographic functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#processes">Processes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#channels">Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#memory-cells">Memory cells</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#id4">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#systems-and-actions">Systems and actions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-defined-macros">System-defined macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-expressions">System expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-contexts">System contexts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#system-binders">System binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#system-annotations">System annotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#axioms-and-lemmas">Axioms and Lemmas</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#judgements">Judgements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logical-variables">Logical variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hypotheses">Hypotheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-judgement">Local judgement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-judgement">Global judgement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#generalities">Generalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tactic-arguments">Tactic arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intro-patterns">Intro patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#proof-terms">Proof terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#proof-term-resolution">Proof-term resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reduction">Reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-simplification-tactics">Automatic simplification tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-errors">Common errors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generic-tactics">Generic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#common-tactics">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-tactics">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-tactics">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-tactics">Structural tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cryptographic-tactics">Cryptographic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-formula">Occurrence formula</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utility-tactics">Utility tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Protocol modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#basic-assumption">Basic assumption</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#cryptographic-assumptions">Cryptographic assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#protocols">Protocols</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#reachability-properties">Reachability properties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial.html#formulas">Formulas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html#equivalence-properties">Equivalence properties</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-declindex.html">Declaration index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="doc-writing.html">Documenting Squirrel with Sphinx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#todo-list-generation">TODO list generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-objects">Squirrel objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#objects">Objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-directives">Squirrel directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-roles">Squirrel roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#common-mistakes">Common mistakes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#improper-nesting">Improper nesting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-token">Overusing <code class="docutils literal notranslate"><span class="pre">:token:</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#omitting-annotations">Omitting annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#using-the-squirreltop-directive-for-syntax-highlighting">Using the <code class="docutils literal notranslate"><span class="pre">..</span> <span class="pre">squirreltop::</span></code> directive for syntax highlighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-plain-quotes">Overusing plain quotes</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-the-example-directive">Overusing the <code class="docutils literal notranslate"><span class="pre">example</span></code> directive</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#tips-and-tricks">Tips and tricks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#nested-lemmas">Nested lemmas</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#abbreviations-and-macros">Abbreviations and macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#advanced-uses-of-notations">Advanced uses of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Squirrel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Proofs</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/squirrel-prover/squirrel-prover/blob/master/documentation/sphinx/source/proofs.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<span class="target" id="section-proofs"></span><section id="proofs">
<h1>Proofs<a class="headerlink" href="#proofs" title="Link to this heading">¶</a></h1>
<p>The proof of a lemma is given after the lemma declaration,
between the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">Proof</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">Qed</span></span></code> markers.
It consists in a list of tactics. The invocation of each
tactic modifies the proof state, which contains a list of goals to prove.
Each goal is displayed as a judgement.
Initially, the proof state consists of a single goal, as declared by the
user. Each tactic then reduces the first goal of the proof state to
an arbitrary number of new sub-goals. When no goal is left, the proof
is completed and <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">Qed</span></span></code> can be used.</p>
<p>The complete list of tactics can be found in the corresponding
<a class="reference internal" href="squirrel-tacindex.html#tactic-index"><span class="std std-ref">tactic index</span></a>.</p>
<section id="judgements">
<span id="section-judgements"></span><h2>Judgements<a class="headerlink" href="#judgements" title="Link to this heading">¶</a></h2>
<p>Squirrel features two kinds of judgements:
local judgements and global judgements.</p>
<section id="logical-variables">
<h3>Logical variables<a class="headerlink" href="#logical-variables" title="Link to this heading">¶</a></h3>
<p><span class="term-defn"><span class="target" id="term-logical_var"></span>Logical variables</span> are free variables in a current goal. Such variables are implicitly quantified universally based on their type and tags.</p>
</section>
<section id="hypotheses">
<h3>Hypotheses<a class="headerlink" href="#hypotheses" title="Link to this heading">¶</a></h3>
<p>Hypotheses are referred to by a hypothesis identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-hypothesis_id"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole">hypothesis_id</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole">ident</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span></section>
<section id="local-judgement">
<h3>Local judgement<a class="headerlink" href="#local-judgement" title="Link to this heading">¶</a></h3>
<p>The general layout for a local judgement is as follows:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>System: currentSystem
</span></dt><dt class="in"><span>Type variables: tvars
</span></dt><dt class="in"><span>Variables: vars
</span></dt><dt class="in"><span>H_1: hypothesis_1
</span></dt><dt class="in"><span>…
</span></dt><dt class="in"><span>H_k: hypothesis_k
</span></dt><dt class="in"><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span class="ansi-fg-light-cyan">—</span><span>
</span></dt><dt class="in"><span>conclusion
</span></dt></dl>
</div>
<p>The judgement asserts that the conclusion below the line holds
in the context given above the line.
We now describe the various components of the judgement:</p>
<ul class="simple">
<li><p>the system <code class="squirrelinline docutils literal notranslate"><span><span class="pre">currentSystem</span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="declarations.html#grammar-token-system_expr"><span class="hole"><span class="pre">system_expr</span></span></a></span></code> in which the
judgement’s formulas should be understood;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">tvars</span></span></code> are the judgement’s <a class="reference internal" href="logic.html#section-polymorphism"><span class="std std-ref">type variables</span></a>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">vars</span></span></code> are the judgement’s term variables with their types and <a class="reference internal" href="logic.html#term-tag"><span class="xref std std-term">tags</span></a>;</p></li>
<li><p>each hypothesis is identified by its hypothesis identifier
(e.g. <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H_1,</span> <span class="pre">H_2</span></span></code>) and is either a global hypothesis, whose body is
a <a class="reference internal" href="logic.html#term-global-formula"><span class="xref std std-term">global formula</span></a>, or a local hypothesis, whose body is a
<a class="reference internal" href="logic.html#term-local-formula"><span class="xref std std-term">local formula</span></a>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">conclusion</span></span></code> is a <a class="reference internal" href="logic.html#term-local-formula"><span class="xref std std-term">local formula</span></a>.</p></li>
</ul>
</section>
<section id="global-judgement">
<h3>Global judgement<a class="headerlink" href="#global-judgement" title="Link to this heading">¶</a></h3>
<p>The general layout for a global judgement is similar to the local one except that now:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">currentSystem</span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="declarations.html#grammar-token-system_context"><span class="hole"><span class="pre">system_context</span></span></a></span></code>;</p></li>
<li><p>all hypotheses, as well as the conclusion, are <a class="reference internal" href="logic.html#term-global-formula"><span class="xref std std-term">global formulas</span></a>.</p></li>
</ul>
</div></blockquote>
<p>When the conclusion is a single <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">equiv(</span></span></span><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">,...,</span></span></span><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> predicate,
all the bi-terms that need to be proved equivalent are displayed as a
numbered list.</p>
<div class="admonition note">
<p class="admonition-title">Example: Initial judgement for observational equivalence</p>
<p>Consider a lemma for observational equivalence, where the
frame is enriched with some public key, as follows:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">global</span><span> </span><span class="ansi-fg-light-blue">lemma</span><span> [myProtocol] obs_equiv t : [</span><span class="ansi-fg-light-green">happens</span><span>(t)] -&gt; </span><span class="ansi-fg-light-blue">equiv</span><span>(</span><span class="ansi-fg-light-green">frame</span><span>&#64;t, pk(sk))
</span></dt></dl>
</div>
<p>When starting its proof, after doing <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">intro</span></span><span> <span class="pre">H</span></span></code>, the goal that the user must prove is displayed as:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>Systems: </span><span class="ansi-fg-light-blue">left</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">right</span><span> (same for equivalences)
</span></dt><dt class="in"><span>Variables: t:</span><span class="ansi-fg-light-cyan">timestamp</span><span>[glob]
</span></dt><dt class="in"><span>H: [</span><span class="ansi-fg-light-green">happens</span><span>(t)]
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span class="ansi-fg-light-blue">0</span><span>: </span><span class="ansi-fg-light-green">frame</span><span>&#64;t
</span></dt><dt class="in"><span class="ansi-fg-light-blue">1</span><span>: pk (sk)
</span></dt></dl>
</div>
</div>
</section>
</section>
<section id="generalities">
<h2>Generalities<a class="headerlink" href="#generalities" title="Link to this heading">¶</a></h2>
<section id="tactic-arguments">
<h3>Tactic arguments<a class="headerlink" href="#tactic-arguments" title="Link to this heading">¶</a></h3>
<p>Tactics that apply to judgements whose conclusion is an equivalence
may take a natural number as argument to identify one item in the equivalence.
This is represented using the <a class="reference internal" href="#grammar-token-position"><code class="xref std std-token docutils literal notranslate"><span class="pre">position</span></code></a> token.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-position"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-position"><span class="hole">position</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole">natural</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Many tactics expecting a term support term <span class="term-defn"><span class="target" id="term-pattern"></span>patterns</span>,
which are underspecified terms that can include term holes
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">_</span></span></code>. Most tactics will match the pattern against
sub-terms of the current goal until it manages to infer values for the term
holes.</p>
<p>Term patterns are produced by appending to the production of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-sterm"><span class="hole"><span class="pre">sterm</span></span></a></span></code> the hole construct:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-term_pat"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole">term_pat</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>…</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-sterm_pat"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-sterm_pat"><span class="hole">sterm_pat</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>…</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>_</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><section id="intro-patterns">
<h4>Intro patterns<a class="headerlink" href="#intro-patterns" title="Link to this heading">¶</a></h4>
<p>Introduction patterns are the principal tool used to do proof-context
<a class="reference external" href="https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html#bookkeeping">book-keeping</a>.
They are used in Squirrel with an SSReflect-inspired syntax.
For a more comprehensive and detailed guide to introduction patterns, see
<a class="reference external" href="https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html#introduction-in-the-context">here</a>.
Note however that Squirrel supports only a sub-set of SSReflect intro
patterns, and that their behaviour in Squirrel may vary in small ways.</p>
<p>Introduction patterns take a different meaning depending
on the tactic in which they are used
(<a class="reference internal" href="#squirrel:tacn.intro" title="intro"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>, <a class="reference internal" href="#squirrel:tacn.have" title="have"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">have</span></code></a>, <a class="reference internal" href="#squirrel:tacn.destruct" title="destruct"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, …). Nonetheless,
a introduction pattern always applies to a set of
focused formulas (sometimes taken in a judgement, with a full
proof-context) which they modify. A introduction pattern may create or
remove focused formulas. Most introduction patterns act only on the top-most
variables or assumptions of the focused formulas (e.g. if the formula
is <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">forall</span></span><span> <span class="pre">x.</span> <span class="pre">G</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H</span> <span class="pre">=&gt;</span> <span class="pre">G</span></span></code> then the pattern will start by acting on
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">x</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H</span></span></code>).</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-naming_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-naming_ip"><span class="hole">naming_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>_</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole">ident</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-and_or_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-and_or_ip"><span class="hole">and_or_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>[]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole">simpl_ip</span></a></span><span class="notation-sup">+</span></span> <span><span>]</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole">simpl_ip</span></a></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simpl_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole">simpl_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-naming_ip"><span class="hole">naming_ip</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-and_or_ip"><span class="hole">and_or_ip</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-rewrite_ip"><span class="hole">rewrite_ip</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-s_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>//</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/=</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>//=</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-rewrite_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-rewrite_ip"><span class="hole">rewrite_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><span><span>-&gt;</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>&lt;-</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-expand_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-expand_ip"><span class="hole">expand_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>&#64;</span></span><span><span>/</span></span><span class="alternative"><span class="alternative-block"><a class="reference internal" href="logic.html#grammar-token-macro_id"><span class="hole">macro_id</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="declarations.html#grammar-token-operator_id"><span class="hole">operator_id</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-clear_switch"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>{</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole">hypothesis_id</span></a></span><span class="notation-sup">+</span></span> <span><span>}</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-intro_pat"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-intro_pat"><span class="hole">intro_pat</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole">simpl_ip</span></a> | <a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> | <a class="reference internal" href="#grammar-token-expand_ip"><span class="hole">expand_ip</span></a> | <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> | <span><span>*</span></span> | <span><span>&gt;</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>A <span class="term-defn"><span class="target" id="term-naming-ip"></span>naming introduction pattern</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-naming_ip"><span class="hole"><span class="pre">naming_ip</span></span></a></span></code> pops
the top-most assumption or universally quantified variable of the
focused formula and introduces it in the proof context,
with a name chosen according to the pattern:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>: using the name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> provided, which fails if
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is already in use;</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span></span></code>: using a name chosen automatically by Squirrel;</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code>: using an automatically chosen name for variables, and the
name <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code> for assumptions, which is a special name that can never
be referred to by the user. Note that, contrary to other
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>, several hypotheses may be named <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code>.</p></li>
</ul>
<p>A <span class="term-defn"><span class="target" id="term-and-or-ip"></span>and/or introduction pattern</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-and_or_ip"><span class="hole"><span class="pre">and_or_ip</span></span></a></span></code> will,
for each focused formula, destruct the top-most assumption of the formula:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <span><span><span class="pre">...</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <span><span><span class="pre">]</span></span></span></span></code>: the top-most assumption of the formula must
be a conjunction with as many conjuncts as simple
patterns are provided.
Destruct the conjunction, handling each conjunct according
to the corresponding <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <span class="pre">|</span> <span><span><span class="pre">...</span></span></span> <span class="pre">|</span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <span><span><span class="pre">]</span></span></span></span></code>: the top-most assumption of the formula
must be a disjunction with as many disjuncts as simple
patterns are provided.
Destruct the disjunction, creating a formula for
each disjunct and handling each of them according to the
corresponding <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Existentials are viewed as conjunctions in intro patterns.
Hence, when the conclusion is of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">(</span></span><span class="ansi-fg-light-blue"><span class="pre">exists</span></span><span> <span class="pre">x,</span> <span class="pre">phi)</span> <span class="pre">=&gt;</span> <span class="pre">psi</span></span></code>,
the tactic <cite>intro [x H]</cite> will introduce a variable <cite>x</cite> and hypothesis
<cite>H : phi</cite>. Here, the conjunctive intro pattern has been used to
destruct the existentially quantified hypothesis during its introduction.</p>
</div>
<p>A <span class="term-defn"><span class="target" id="term-simplification-item"></span>simplification item</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole"><span class="pre">s_item</span></span></a></span></code>
simplifies the focused formulas:</p>
<ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">//</span></span></code> removes all formulas on which <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">auto</span></span></code> concludes;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">/=</span></span></code> simplifies all formulas using <a class="reference internal" href="#squirrel:tacn.simpl" title="simpl"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">//=</span></span></code> is short-hand for <code class="squirrelinline docutils literal notranslate"><span><span class="pre">//</span> <span class="pre">/=</span></span></code>;</p></li>
</ul>
<p>A <span class="term-defn"><span class="target" id="term-rewrite-ip-item"></span>rewrite intro pattern item</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-rewrite_ip"><span class="hole"><span class="pre">rewrite_ip</span></span></a></span></code>
uses the top-most assumption to rewrite the focused formulas. The top
assumption is cleared after rewriting.</p>
<ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">-&gt;</span></span></code> reads the top-most assumption as a left-to-right rewrite rule.</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;-</span></span></code> reads the top-most assumption as a right-to-left rewrite rule.</p></li>
</ul>
<p>An <span class="term-defn"><span class="target" id="term-expansion-item"></span>expansion item</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-expand_ip"><span class="hole"><span class="pre">expand_ip</span></span></a></span></code> expands definitions in the focused formulas:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&#64;</span></span></span><span><span><span class="pre">/</span></span></span><a class="reference internal" href="logic.html#grammar-token-macro_id"><span class="hole"><span class="pre">macro_id</span></span></a></span></code> expands the applications of the macro symbol;
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-macro_id"><span class="hole"><span class="pre">macro_id</span></span></a></span></code> whenever it is applied to a time-point that can be
shown to happen;</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&#64;</span></span></span><span><span><span class="pre">/</span></span></span><a class="reference internal" href="declarations.html#grammar-token-operator_id"><span class="hole"><span class="pre">operator_id</span></span></a></span></code> expands the operator <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="declarations.html#grammar-token-operator_id"><span class="hole"><span class="pre">operator_id</span></span></a></span></code>,
<span class="math notranslate nohighlight">\(\beta\)</span>-reducing the operator if it is applied.</p></li>
</ul>
<p>A <span class="term-defn"><span class="target" id="term-clear-switch"></span>clear switch</span> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole"><span class="pre">clear_switch</span></span></a></span></code> clears the
specified hypotheses from the proof context.</p>
</section>
</section>
<section id="proof-terms">
<h3>Proof terms<a class="headerlink" href="#proof-terms" title="Link to this heading">¶</a></h3>
<p>Proof terms are used by several tactics (see e.g. <a class="reference internal" href="#squirrel:tacn.have" title="have"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">have</span></code></a> or
<a class="reference internal" href="#squirrel:tacn.apply" title="apply"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>) as a convenient way to combine and (partially) apply
hypotheses, axioms or proved lemmas, in order to derive new facts.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-proof_term"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole">proof_term</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-pt_arg"><span class="hole">pt_arg</span></a></span><span class="notation-sup">*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-pt_arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-pt_arg"><span class="hole">pt_arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-sterm_pat"><span class="hole">sterm_pat</span></a> | <a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole">ident</span></a> | <span><span>(%</span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole">proof_term</span></a><span><span>)</span></span> | <span><span>_</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>In a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> or a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-pt_arg"><span class="hole"><span class="pre">pt_arg</span></span></a></span></code>, an identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> must
refer to a hypothesis in the current proof context, an axiom or a
previously proved lemma.</p>
<p>Note that the grammar for proof term arguments <a class="reference internal" href="#grammar-token-pt_arg"><code class="xref std std-token docutils literal notranslate"><span class="pre">pt_arg</span></code></a> is
ambiguous (because of the <a class="reference internal" href="reference-intro.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and <a class="reference internal" href="logic.html#grammar-token-sterm"><code class="xref std std-token docutils literal notranslate"><span class="pre">sterm</span></code></a>
productions). When this happens, Squirrel tries to desambiguate using
the context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(%</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a><span><span><span class="pre">)</span></span></span></span></code> syntax is experimental, and is subject to
change in the future.</p>
</div>
<section id="proof-term-resolution">
<span id="section-pt-resolution"></span><h4>Proof-term resolution<a class="headerlink" href="#proof-term-resolution" title="Link to this heading">¶</a></h4>
<p>A proof-term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-pt_arg"><span class="hole"><span class="pre">pt_arg</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">...</span></span></span> <a class="reference internal" href="#grammar-token-pt_arg"><span class="hole"><span class="pre">pt_arg</span><sub><span class="pre">n</span></sub></span></a></span></code> is
resolved into a local or global formula as follows:</p>
<ul class="simple">
<li><p>First, the proof-term head <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is resolved as a <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">local_formula</span></span></span></code>
or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-global_formula"><span class="hole"><span class="pre">global_formula</span></span></a></span></code> <code class="squirrelinline docutils literal notranslate"><span><span class="pre">F</span></span></code>.</p></li>
<li><p>Then, this local or global formula <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code> is successively modified
by applying to it the arguments <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-pt_arg"><span class="hole"><span class="pre">pt_arg</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">...</span></span></span> <a class="reference internal" href="#grammar-token-pt_arg"><span class="hole"><span class="pre">pt_arg</span><sub><span class="pre">n</span></sub></span></a></span></code>, in
order, as follows:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-sterm_pat"><span class="hole"><span class="pre">sterm_pat</span></span></a></span></code>: the top-most element of
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code> must be a universally quantified variable, which is then
substituted with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-sterm_pat"><span class="hole"><span class="pre">sterm_pat</span></span></a></span></code>, e.g. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x,</span></span></span> <span><span><span class="pre">F0</span></span></span></span></code> is replaced
with <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(F0</span></span></span><span class="curlies"><span class="pre">{</span><span><span><span class="pre">x</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <a class="reference internal" href="logic.html#grammar-token-sterm"><span class="hole"><span class="pre">sterm</span></span></a><span class="pre">}</span></span><span><span><span class="pre">)</span></span></span></span></code>.  Moreover, a new term unification
variable is created for each hole <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code> in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-sterm_pat"><span class="hole"><span class="pre">sterm_pat</span></span></a></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>: the top-most element of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>
must be an assumption, which is popped and unified with the formula
corresponding to the hypothesis, axiom or lemma identified
by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(%</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a><span><span><span class="pre">)</span></span></span></span></code>: the proof-term argument
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> is recursively resolved into a formula, which is
then unified with the top-most element of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">_</span></span></span></span></code>: if <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>’s top-most element is a universally quantified variable
then a new unification variable is created and applied to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>.
If <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>’s top-most element is an assumption <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H</span></span></span></span></code>, a new sub-goal
requiring to prove <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H</span></span></span></span></code> is created and must be discharged by the user.</p></li>
</ul>
</li>
<li><p>Finally, depending on which tactic uses the proof-term, Squirrel
checks that the term unification variables can all be inferred,
generalizes the term unification variables that remain, or leaves
the term unification environment unclosed.</p></li>
</ul>
<p>In practice, the application of a proof-term argument is more complex
than described above, for several reasons:</p>
<ul class="simple">
<li><p>checks must be perfomed to ensure the compatibility of the systems
corresponding to the applied formulas,
e.g. applying an axiom over system <code class="squirrelinline docutils literal notranslate"><span><span class="pre">[</span></span><span class="ansi-fg-light-blue"><span class="pre">any</span></span><span><span class="pre">]</span></span></code>
to a formula over system <code class="squirrelinline docutils literal notranslate"><span><span class="pre">[default]</span></span></code> is valid, but the
converse is not;</p></li>
<li><p>some formula manipulations occur when trying to mix global and local
formulas, e.g. when applying a global formula to a local formula.</p></li>
</ul>
</section>
</section>
<section id="reduction">
<span id="id2"></span><h3>Reduction<a class="headerlink" href="#reduction" title="Link to this heading">¶</a></h3>
<p>Several tactics (e.g., <a class="reference internal" href="#squirrel:tacn.simpl" title="simpl"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">simpl</span></code></a> and <a class="reference internal" href="#squirrel:tacn.auto" title="auto"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>) rely on a
reduction engine. This engine repeatedly applies several
transformations, corresponding to the following flags.</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-simpl_flags"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-simpl_flags"><span class="hole">simpl_flags</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>~flags:[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>rw</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>beta</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>proj</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>delta</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>constr</span></span></span></span></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Leaving the flags unspecified results in the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">beta</span></span></code> and
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">proj</span></span></code> transformations being used. Specifying an empty list of
flags results in no transformations being applied. Otherwise, only the
specified transformations are applied, as described next:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw</span></span></code>: perform user-defined rewriting;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">beta</span></span></code>: perform beta-reductions;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">proj</span></span></code>: compute tuple projections;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">delta</span></span></code>: replace macros and operators with their definitions;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">constr</span></span></code>: automatically simplify trace formulas using
constraint reasoning.</p></li>
</ul>
</div></blockquote>
<p>The <code class="squirrelinline docutils literal notranslate"><span><span class="pre">constr</span></span></code> transformation replaces trace (sub-)formulas that
are provably equal to <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">true</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">false</span></span></code> with that value.
When doing so, the constraint solver takes into account
the current hypotheses but also the conditionals that surround
the trace formula.</p>
<p>The user-defined rewriting transformation eagerly applies the rewrite
rules added to the rewriting database using the <a class="reference internal" href="commands.html#squirrel:cmd.hint-rewrite" title="hint rewrite"><code class="xref squirrel squirrel-cmd docutils literal notranslate"><span class="pre">hint</span> <span class="pre">rewrite</span></code></a>
command.</p>
</section>
<section id="automatic-simplification-tactics">
<h3>Automatic simplification tactics<a class="headerlink" href="#automatic-simplification-tactics" title="Link to this heading">¶</a></h3>
<p>There are three automated tactics. The <a class="reference internal" href="#squirrel:tacn.autosimpl" title="autosimpl"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">autosimpl</span></code></a> tactic is
called automatically after each tactic, unless the tactical
<a class="reference internal" href="#squirrel:tacn.nosimpl" title="nosimpl"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">nosimpl</span></code></a> is used.</p>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.auto">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">auto</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simpl_flags"><span class="hole"><span class="pre">simpl_flags</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.auto" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to automatically prove a goal using the hypotheses.</p>
<p>The tactic uses the <a class="reference internal" href="#reduction"><span class="std std-ref">reduction engine</span></a>
with the provided flags (defaults to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw,beta,proj</span></span></code>).</p>
<p>Moreover, for local goals, the tactic relies on basic
propositional reasoning, rewriting simplications, and both
<a class="reference internal" href="#squirrel:tacn.constraints" title="constraints"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">constraints</span></code></a> and <a class="reference internal" href="#squirrel:tact.congruence" title="congruence"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>.</p>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="id3">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cannot</span></span></span> <span><span><span class="pre">close</span></span></span> <span><span><span class="pre">goal</span></span></span></span></span><a class="headerlink" href="#id3" title="Link to this definition">¶</a></dt>
<dd><p>The current goal could not be closed.</p>
</dd></dl>

</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.autosimpl">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">autosimpl</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.autosimpl" title="Link to this definition">¶</a></dt>
<dd><p>Simplify a goal, without closing it.</p>
<p>The tactic uses the <a class="reference internal" href="#reduction"><span class="std std-ref">reduction engine</span></a>
with the flags <code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw,beta,proj</span></span></code>.</p>
<p>When the conclusion of the goal is a conjunction, it splits the
goal into several sub-goals, automatically closing only the trivial
goals proved by <a class="reference internal" href="#squirrel:tact.true" title="true"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">true</span></code></a> and <a class="reference internal" href="#squirrel:tacn.assumption" title="assumption"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a>.</p>
<p>When the conclusion of the goal is a global formula which only contains
a local formula, the goal is then turned into a local formula. Otherwise
the tactic does nothing.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.simpl">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">simpl</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simpl_flags"><span class="hole"><span class="pre">simpl_flags</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.simpl" title="Link to this definition">¶</a></dt>
<dd><p>Simplify a goal and its hypotheses.
This tactic always succeeds, replacing the initial goal with
a single simplified goal.</p>
<p>The tactic uses the <a class="reference internal" href="#reduction"><span class="std std-ref">reduction engine</span></a>
with the provided flags (defaults to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw,beta,proj</span></span></code>).</p>
<p>When the goal is a conjunction, the tactic
will attempt to automatically prove some conjuncts (using <a class="reference internal" href="#squirrel:tacn.auto" title="auto"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>)
and will then return a simplified sub-goal without these conjuncts.
In the degenerate case where no conjunct remains, the goal will be <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">true</span></span></code>.</p>
<p>When the conclusion of the goal is an equivalence, the tactic
will automatically perform <a class="reference internal" href="#squirrel:tacn.fa" title="fa"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fa</span></code></a> when at most one of the remaining
sub-terms is non-deducible. It may thus remove a deducible item
from the equivalence, or replace an item <code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;u,v&gt;</span></span></code> with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">u</span></span></code>
if it determines that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">v</span></span></code> is deducible.</p>
</dd></dl>

</section>
<section id="tactics">
<span id="section-tactics"></span><h3>Tactics<a class="headerlink" href="#tactics" title="Link to this heading">¶</a></h3>
<p>The full syntax of tactic combinations is as follows:</p>
<span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tactic"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a><span><span>;</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>tac</span></span><span><span>_</span></span><span><span>selector</span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a><span><span>;</span></span> <span><span>[</span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><span><span>tac</span></span><span><span>_</span></span><span><span>selector</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span><span>]</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>+</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>by</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>nosimpl</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>try</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><span><span>repeat</span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><code class="docutils literal notranslate"></code></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">|</span></code></span><span class="prodn-cell-production"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole">tactic</span></a> <span><span>=&gt;</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intro_pat"><span class="hole">intro_pat</span></a></span><span class="notation-sup">+</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-tac_selector"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-tac_selector"><span class="hole">tac_selector</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">*</span><span class="notation-sub">,</span></span> <span><span>:</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Tactic combinators behaves as follows:</p>
<ul class="simple">
<li><p>the semi-column <code class="squirrelinline docutils literal notranslate"><span><span class="pre">;</span></span></code> is used for judgemential composition. The
second tactic is applied to all sub-goals created by the first one,
unless the indices of some sub-goals are specified using a
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tac_selector"><span class="hole"><span class="pre">tac_selector</span></span></a></span></code>.</p></li>
<li><p>A different tactic can be applied to different sub-goals, for
example <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">[1:</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a> <span class="pre">|</span> <span><span><span class="pre">3,4:</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a><span><span><span class="pre">]</span></span></span></span></code> applies
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">1</span></sub></span></a></span></code> to the first created sub-goal, and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span><sub><span class="pre">2</span></sub></span></a></span></code>
to the third and fourth sub-goals.</p></li>
<li><p>The <code class="squirrelinline docutils literal notranslate"><span><span class="pre">+</span></span></code> combinator performs an or-else, i.e. tries applying the
first tactic, and if that fails, applies the second one.</p></li>
</ul>
<p>The remainder behaves as follows:</p>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.by">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">by</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.by" title="Link to this definition">¶</a></dt>
<dd><p>Fail unless the tactic closes the goal.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.nosimpl">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">nosimpl</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.nosimpl" title="Link to this definition">¶</a></dt>
<dd><p>Call the given tactic without the implicit use of simplifications.
This can be useful to understand what’s going on step by step.
This is also necessary in rare occasions where simplifications are
actually undesirable to complete the proof.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.try">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">try</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.try" title="Link to this definition">¶</a></dt>
<dd><p>Try to apply the given tactic. If it fails, succeed with the
sub-goal left unchanged.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.repeat">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">repeat</span></span></span> <a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.repeat" title="Link to this definition">¶</a></dt>
<dd><p>Apply the given tactic, and recursively apply it again on the
generated sub-goals, until it fails.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-intro_pat_list"><span class="hole"><span class="pre">intro_pat_list</span></span></a></span></span></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-intro_pat_list"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-intro_pat_list"><span class="hole">intro_pat_list</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intro_pat"><span class="hole">intro_pat</span></a></span><span class="notation-sup">*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="#grammar-token-intro_pat_list"><span class="hole"><span class="pre">intro_pat_list</span></span></a></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-tactic"><span class="hole"><span class="pre">tactic</span></span></a><span><span><span class="pre">;</span></span></span> <span><span><span class="pre">intro</span></span></span> <a class="reference internal" href="#grammar-token-intro_pat_list"><span class="hole"><span class="pre">intro_pat_list</span></span></a></span></code></p>
</dd></dl>

</section>
<section id="common-errors">
<h3>Common errors<a class="headerlink" href="#common-errors" title="Link to this heading">¶</a></h3>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Out-of-range-position">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Out</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">range</span></span></span> <span><span><span class="pre">position.</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Out-of-range-position" title="Link to this definition">¶</a></dt>
<dd><p>Argument does not correspond to a valid equivalence item.</p>
</dd></dl>

<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Assumption-not-over-valid-system">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Assumption</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">over</span></span></span> <span><span><span class="pre">valid</span></span></span> <span><span><span class="pre">system</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Assumption-not-over-valid-system" title="Link to this definition">¶</a></dt>
<dd><p>Trying to use a proof term that does not apply to the current system.</p>
</dd></dl>

</section>
</section>
<section id="id4">
<h2>Tactics<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>Tactics are organized in three categories:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#section-generic-tactics"><span class="std std-ref">generic tactics</span></a>, that rely on generic logical reasoning;</p></li>
<li><p><a class="reference internal" href="#section-structural-tactics"><span class="std std-ref">structural tactics</span></a>, that rely on properties of protocols and equality;</p></li>
<li><p><a class="reference internal" href="#section-crypto-tactics"><span class="std std-ref">cryptographic tactics</span></a>, that rely on
cryptographic assumptions.</p></li>
</ul>
</div></blockquote>
<p>In addition, they are also split between tactics applicable to local
goals only, global goals only, or tactics common to both types of
goals. Remark that applying a tactic to a local goal may produce a
global sub-goal, and conversely.</p>
<p>Additionally, there are a few <a class="reference internal" href="#section-utility-tactics"><span class="std std-ref">utility tactics</span></a> listed at the end.</p>
<section id="generic-tactics">
<span id="section-generic-tactics"></span><h3>Generic tactics<a class="headerlink" href="#generic-tactics" title="Link to this heading">¶</a></h3>
<section id="common-tactics">
<h4>Common tactics<a class="headerlink" href="#common-tactics" title="Link to this heading">¶</a></h4>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.admit">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">admit</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.admit" title="Link to this definition">¶</a></dt>
<dd><p>Admit the current goal, or admit the element at position
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span></code> when the goal is an equivalence.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.assumption">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assumption</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.assumption" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Conclude if the conclusion of the current goal (or <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">false</span></span></code>) appears in the hypotheses. The
hypothesis to be checked against may be directly specified using
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.case">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">case</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></span></span></span><a class="headerlink" href="#squirrel:tacn.case" title="Link to this definition">¶</a></dt>
<dd><p>Perform a case analysis over the given argument:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>: create one sub-goal for each disjunct of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code> a term of type <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span></code>: create one sub-goal
for each possible <a class="reference internal" href="declarations.html#term-action-constructor"><span class="xref std std-term">action constructor</span></a> of the
current goal’s system
(all systems appearing in a judgement have the same set of actions,
as they must be be compatible).</p></li>
</ul>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.induction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">induction</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span><span><span><span class="pre">:</span></span></span><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.induction" title="Link to this definition">¶</a></dt>
<dd><p>Apply the induction scheme to the conclusion. The behaviour of the tactic
depends on the type of the current goal, and whether the optional arguments are given.</p>
<p>For a local goal, if no argument is specified, the
conclusion must start with a universal quantification over a
well-founded type and the induction is performed over the
first quantified variable. If a term is manually
specified, the goal is first generalized (see
<a class="reference internal" href="#squirrel:tacn.generalize" title="generalize"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>) w.r.t. that term, understood in system <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a></span></code>.
Only then is the induction applied.</p>
<p>For a global goal, an argument must always be specified,
and,</p>
<blockquote>
<div><ul class="simple">
<li><p>if the given term is a timestamp variable, a weak induction is
performed over this variable, as well as a case disjunction over all
possible actions;</p></li>
<li><p>for any other term argument, the
tactic behaves as in the local case.</p></li>
</ul>
</div></blockquote>
<p>The weak induction variant is in fact the most widely used tactic
in current Squirrel examples to prove the observational equivalence
of a protocol.</p>
<div class="admonition note">
<p class="admonition-title">Example: Induction for observational equivalence.</p>
<p>Over a goal of the form</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>Systems: </span><span class="ansi-fg-light-blue">left</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">right</span><span> (same for equivalences)
</span></dt><dt class="in"><span>Variables: t:</span><span class="ansi-fg-light-cyan">timestamp</span><span>[glob]
</span></dt><dt class="in"><span>H: [</span><span class="ansi-fg-light-green">happens</span><span>(t)]
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span class="ansi-fg-light-blue">0</span><span>: </span><span class="ansi-fg-light-green">frame</span><span>&#64;t
</span></dt></dl>
</div>
<p>Calling <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">induction</span></span><span> <span class="pre">t</span></span></code> will apply the weak
induction and case disjunction,
yielding as many goals as there are actions
in the protocol, plus one additional goal for the
initialization. Assuming an action <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code> is in the protocol,
that has a total of 3 actions, a sub-goal created for the case of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code>
looks like</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">4</span><span>):
</span></dt><dt class="in"><span>Systems: </span><span class="ansi-fg-light-blue">left</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:myProtocol/</span><span class="ansi-fg-light-blue">right</span><span> (same for equivalences)
</span></dt><dt class="in"><span>H: [</span><span class="ansi-fg-light-green">happens</span><span>(A)]
</span></dt><dt class="in"><span>IH:  </span><span class="ansi-fg-light-blue">equiv</span><span>(</span><span class="ansi-fg-light-green">frame</span><span>&#64;pred (A))
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span class="ansi-fg-light-blue">0</span><span>: </span><span class="ansi-fg-light-green">frame</span><span>&#64;A
</span></dt></dl>
</div>
</div>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.dependent-induction">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">dependent</span></span></span> <span><span><span class="pre">induction</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span><span><span><span class="pre">:</span></span></span><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-variable"><span class="hole"><span class="pre">variable</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.dependent-induction" title="Link to this definition">¶</a></dt>
<dd><p>Apply the induction scheme to the conclusion. If no argument is
specified, the conclusion must be a universal quantification over
a well-founded type. Alternatively, a term of a well-founded type
can be given as argument, in which case the goal is first
generalized in the dependent variant (see <a class="reference internal" href="#squirrel:tacn.generalize-dependent" title="generalize dependent"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">generalize</span>
<span class="pre">dependent</span></code></a>) before proceeding with the induction.</p>
<p>This tactic always uses a strong induction principle (as opposed
to the <a class="reference internal" href="#squirrel:tacn.induction" title="induction"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic, which performs a weak induction
when the conclusion is an equivalences).</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.destruct">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">destruct</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.destruct" title="Link to this definition">¶</a></dt>
<dd><p>Destruct a hypothesis based on its top-most connective
(existential quantification, disjunction or conjunction),
applying the simple introduction pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code> to it.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code> defaults to <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span></span></code> if no pattern is provided by the user.</p>
<div class="admonition note">
<p class="admonition-title">Example: Destruct</p>
<p>If we have the hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H:</span> <span class="pre">A</span> <span class="pre">\/</span> <span class="pre">(B</span> <span class="pre">/\</span> <span class="pre">C)</span></span></code>, the tactic</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">destruct</span><span> H </span><span class="ansi-fg-light-blue">as</span><span> [H1 | [H2 H3]]
</span></dt></dl>
</div>
<p>removes the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H</span></span></code> hypothesis and creates two sub-goals,
one with the hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H1:A</span></span></code>,
the other with the hypotheses <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H2:B,</span> <span class="pre">H3:C</span></span></code>.</p>
</div>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.exists">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">exists</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.exists" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">exists</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">...</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span></a></span></code> uses the terms <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a> <span><span><span class="pre">...</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span></a></span></code>
as witnesses to prove an existentially quantified conclusion.</p>
<p>For example, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">exists</span></span><span> <span class="pre">t</span></span></code> transforms the conclusion of a goal
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(exists</span></span></span> <span><span><span class="pre">x,</span></span></span> <span><span><span class="pre">phi)</span></span></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(phi</span></span></span><span class="curlies"><span class="pre">{</span><span><span><span class="pre">x</span></span></span> <span><span><span class="pre">-&gt;</span></span></span> <span><span><span class="pre">t</span></span></span><span class="pre">}</span></span><span><span><span class="pre">)</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.generalize">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span><span><span><span class="pre">:</span></span></span><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-variable"><span class="hole"><span class="pre">variable</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.generalize" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span><span><span><span class="pre">:</span></span></span><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code> looks in the conclusion of the sequent for an instance <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code> understood in system <cite>&#64;expr_annot</cite>. Then, it replaces all occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
in the conclusion with a fresh universally quantified variable
(automatically named, or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-variable"><span class="hole"><span class="pre">variable</span></span></a></span></code> if provided).</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span></span></code> argument, which specifies in which system the given terms are to be understood,
is optional. If no system is provided, terms are by default
understood in the current goal’s <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">set</span></span></span></span></code> for a local goal,
and in its <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">equiv</span></span></span></span></code> in global goals.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.generalize-dependent">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">generalize</span></span></span> <span><span><span class="pre">dependent</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">&#64;</span></span></span><span class="hole"><span class="pre">system</span></span><span><span><span class="pre">:</span></span></span><a class="reference internal" href="declarations.html#grammar-token-expr_annot"><span class="hole"><span class="pre">expr_annot</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-variable"><span class="hole"><span class="pre">variable</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.generalize-dependent" title="Link to this definition">¶</a></dt>
<dd><p>Same as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">generalize</span></span></span></span></code>, but also generalizes in the proof context.
All hypotheses in which generalization occurred are pushed back into the
conclusion before the newly added quantified variables.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.have">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a> <span><span><span class="pre">:</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="logic.html#grammar-token-global_formula"><span class="hole"><span class="pre">global_formula</span></span></a></span></span></span></span><a class="headerlink" href="#squirrel:tacn.have" title="Link to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-have_ip"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-have_ip"><span class="hole">have_ip</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="notation-sup">*</span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole">simpl_ip</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="notation-sup">*</span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">F</span></span></span></span></code> introduces the new hypothesis <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>, which
can be a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> or a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-global_formula"><span class="hole"><span class="pre">global_formula</span></span></a></span></code>. The new
hypothesis is processed by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a></span></code> (see below). A new
sub-goal requiring to prove <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code> is created.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a></span></code> is the introduction pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole"><span class="pre">s_item</span><sub><span class="pre">pre</span></sub></span></a> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <a class="reference internal" href="#grammar-token-s_item"><span class="hole"><span class="pre">s_item</span><sub><span class="pre">post</span></sub></span></a></span></code> then:</p>
<ul class="simple">
<li><p>the simplification item <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole"><span class="pre">s_item</span><sub><span class="pre">pre</span></sub></span></a></span></code> is applied to the <em>conclusion</em>
before adding the hypothesis;</p></li>
<li><p>the simple intro-pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code> is applied to introduce the
<em>new hypothesis</em> <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>;</p></li>
<li><p>the simplification item <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-s_item"><span class="hole"><span class="pre">s_item</span><sub><span class="pre">post</span></sub></span></a></span></code> is applied to the <em>conclusions</em>
after adding the hypothesis.</p></li>
</ul>
<p>It there are mutliple pre or post simplification items, they are
applied in order.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.assert">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">assert</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.assert" title="Link to this definition">¶</a></dt>
<dd><p>This is an alternative syntax for <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a> <span><span><span class="pre">:</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>,
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code> defaults to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">?</span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="id5">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></span><a class="headerlink" href="#id5" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> <a class="reference internal" href="#section-pt-resolution"><span class="std std-ref">resolves</span></a>
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> — requiring that the term unification
enviroment is closed — and processes the resulting formula using introduction
pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.apply">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">apply</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.apply" title="Link to this definition">¶</a></dt>
<dd><p>Backward reasoning tactic.
First, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> is <a class="reference internal" href="#section-pt-resolution"><span class="std std-ref">resolved</span></a> as a
formula <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span><sub><span class="pre">pt</span></sub></span></span></code>
— without closing the term unification environment.
Then, it is unified with the conclusion, and finally the term
unification environment is closed.</p>
<p>If the unification of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span><sub><span class="pre">pt</span></sub></span></span></code> with the conclusion fails, the tactic
introduces
the top-most element of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span><sub><span class="pre">pt</span></sub></span></span></code> as described below, and then tries
again to unify with
the conclusion:</p>
<ul class="simple">
<li><p>if it is a variable (i.e. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span><sub><span class="pre">pt</span></sub></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x,</span></span></span> <span><span><span class="pre">F</span></span></span></span></code>), it
introduces a new term
unification variable <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x</span></span></span></span></code> and continues from <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>;</p></li>
<li><p>if it is an assumption (i.e. <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span><sub><span class="pre">pt</span></sub></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">G</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">F</span></span></span></span></code>), the
assumption <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">G</span></span></span></span></code> is discharged as a new sub-goal,
and the tactic continues from <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code>.</p></li>
</ul>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="id6">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">apply</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a> <span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></span><a class="headerlink" href="#id6" title="Link to this definition">¶</a></dt>
<dd><p>Forward reasoning variant of <a class="reference internal" href="#squirrel:tacn.apply" title="apply"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>, which unifies the
premisses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> against the conclusion of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>, replacing <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code> content with
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code>’s conclusion.</p>
<p>For instance, if <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H1:A=&gt;B</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H2:A</span></span></span></span></code>, then <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">apply</span></span><span> <span class="pre">H1</span> </span><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span> <span class="pre">H2</span></span></code>
replaces
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H2:A</span></span></span></span></code> with <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H2:B</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.rewrite">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">rewrite</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-rw_arg"><span class="hole"><span class="pre">rw_arg</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-rw_target"><span class="hole"><span class="pre">rw_target</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.rewrite" title="Link to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-rw_arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-rw_arg"><span class="hole">rw_arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><a class="reference internal" href="#grammar-token-rw_item"><span class="hole">rw_item</span></a></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-rw_item"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-rw_item"><span class="hole">rw_item</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole">natural</span></a></span><span class="notation-sup">?</span></span> <span><span>!</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span>-</span></span></span><span class="notation-sup">?</span></span> <span class="alternative"><span class="alternative-block"><span><span>(</span></span><a class="reference internal" href="#grammar-token-proof_term"><span class="hole">proof_term</span></a><span><span>)</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/</span></span><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/(</span></span> <a class="reference internal" href="reference-intro.html#grammar-token-infix_op"><span class="hole">infix_op</span></a><span><span>)</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>/*</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-rw_target"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-rw_target"><span class="hole">rw_target</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole">hypothesis_id</span></a></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>*</span></span></span></span></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Apply a sequence of <a class="reference internal" href="#term-rewrite-ip-item"><span class="xref std std-term">rewriting</span></a>
and <a class="reference internal" href="#term-simplification-item"><span class="xref std std-term">simplification</span></a> items to the rewrite target, which is:</p>
<ul class="simple">
<li><p>the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code> if <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">rw</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">target</span></span></span> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>;</p></li>
<li><p>all hypotheses if <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">rw</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">target</span></span></span> <span><span><span class="pre">=</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></code>;</p></li>
<li><p>the conclusion if no specific rewrite target is given.</p></li>
</ul>
<p><span class="term-defn"><span class="target" id="term-rewrite-item"></span>Rewrite items</span> are applied as follows:</p>
<ul class="simple">
<li><p>proof term rewrite item <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code>:</p>
<ul>
<li><p>It is first <a class="reference internal" href="#section-pt-resolution"><span class="std std-ref">resolved</span></a> — without closing the
term unification environment — as a local formula <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span></span></code> or
global formula <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[F]</span></span></span></span></code> where
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">forall</span></span></span> <span><span><span class="pre">x1...xn,</span></span></span> <span><span><span class="pre">H1=&gt;...=&gt;Hn=&gt;</span></span></span> <span><span><span class="pre">l</span></span></span> <span><span><span class="pre">=</span></span></span> <span><span><span class="pre">r</span></span></span></span></code>.
At that point, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">l</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">r</span></span></span></span></code> are swapped if the rewrite item is prefixed by <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">-</span></span></span></span></code>.</p></li>
<li><p>Then, Squirrel tries to unify <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">l</span></span></span></span></code> with a sub-term of the
rewrite target, where <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">x1...xn</span></span></span></span></code> are handled as term
unification variables. If it succeeds, all occurrences of the
matched instance of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">l</span></span></span></span></code> are replaced with the corresponding
instantiation of <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">r</span></span></span></span></code>.</p></li>
<li><p>The term unification environment is closed, and new sub-goals are created
for the instantiated assumptions <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H1,...,Hn</span></span></span></span></code>.</p></li>
</ul>
</li>
<li><p>expansion items <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">/</span></span></span><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">/(</span></span></span> <a class="reference internal" href="reference-intro.html#grammar-token-infix_op"><span class="hole"><span class="pre">infix_op</span></span></a><span><span><span class="pre">)</span></span></span></span></code> tries to expand the corresponding
symbol (see <a class="reference internal" href="#term-expansion-item"><span class="xref std std-term">expansion item</span></a>), while <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">/*</span></span></span></span></code> tries to
expand all possible symbols;</p></li>
<li><p><code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">!</span></span></span></span></code> applies the rewrite item as many times as possible, but at least once,
while <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">(</span></span></span><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a> <span><span><span class="pre">!)</span></span></span></span></code> applies the rewrite item <em>exactly</em> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span></code> times.
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">?</span></span></span></span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">!</span></span></span></span></code>, except that the rewrite item may be applied zero times.
Otherwise, the rewrite item must be applied exactly once.</p></li>
</ul>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.rule-bad-systems">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">rule</span></span></span> <span><span><span class="pre">bad</span></span></span> <span><span><span class="pre">systems</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.rule-bad-systems" title="Link to this definition">¶</a></dt>
<dd><p>Rewrite item applies to a system which is not compatible with the rewrite target.</p>
</dd></dl>

<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.nothing-to-rewrite">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">nothing</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">rewrite</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.nothing-to-rewrite" title="Link to this definition">¶</a></dt>
<dd><p>No instance of the rewrite rule were found.</p>
</dd></dl>

<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.max-nested-rewriting-reached">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">max</span></span></span> <span><span><span class="pre">nested</span></span></span> <span><span><span class="pre">rewriting</span></span></span> <span><span><span class="pre">reached</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.max-nested-rewriting-reached" title="Link to this definition">¶</a></dt>
<dd><p>There were too many nested rewriting. This is to avoid infinite rewriting loops.</p>
</dd></dl>

</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.id">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">id</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.id" title="Link to this definition">¶</a></dt>
<dd><p>The identity tactic, which does nothing. Sometimes useful when
using <a class="reference internal" href="#section-tactics"><span class="std std-ref">tactic combinators</span></a>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.intro">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">intro</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-intro_pat"><span class="hole"><span class="pre">intro_pat</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.intro" title="Link to this definition">¶</a></dt>
<dd><p>Introduce the top-most assumptions and universally quantified
variables of the conclusion as specified by the given introduction
patterns.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.clear">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">clear</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="reference-intro.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.clear" title="Link to this definition">¶</a></dt>
<dd><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">clear</span></span><span> </span><span class="ansi-fg-light-blue"><span class="pre">id</span></span></code> drops the specified hypothesis, variable declaration or
definition, as long as <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">id</span></span></code> is not used elsewhere in the sequent.</p>
<p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">clear</span></span><span> <span class="pre">id1</span> <span class="pre">...</span> <span class="pre">idN</span></span></code> is syntactic sugar for <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">clear</span></span><span> <span class="pre">id1;</span> <span class="pre">...;</span> </span><span class="ansi-fg-light-blue"><span class="pre">clear</span></span><span> <span class="pre">idN</span></span></code>.</p>
<p>Calling <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">clear</span></span></code> without arguments clears all possible unused
variable declarations and definitions.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.reduce">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">reduce</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-simpl_flags"><span class="hole"><span class="pre">simpl_flags</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.reduce" title="Link to this definition">¶</a></dt>
<dd><p>Reduce all terms in a goal, working on both hypotheses and conclusion.</p>
<p>This tactic always succeeds, replacing the initial goal with a
unique sub-goal (which may be identical to the initial one).</p>
<p>The tactic uses the <a class="reference internal" href="#reduction"><span class="std std-ref">reduction engine</span></a>
with the provided flags (defaults to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">rw,beta,proj</span></span></code>).</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.remember">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">remember</span></span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.remember" title="Link to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#squirrel:tacn.remember" title="remember"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">remember</span></code></a> behaves as <a class="reference internal" href="#squirrel:tacn.generalize" title="generalize"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>, except that it adds
as a hypothesis the equality between the generalized term and the
new variable.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.revert">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">revert</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.revert" title="Link to this definition">¶</a></dt>
<dd><p>Remove the hypotheses from the proof context, and add them back
into the conclusion of the goal.</p>
<p>For example, running <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">revert</span></span></span> <span><span><span class="pre">H</span></span></span></span></code> on the judgement
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">H</span></span></span> <span><span><span class="pre">:</span></span></span> <span><span><span class="pre">F,</span></span></span> <span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">conc</span></span></span></span></code> yields <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span> <span><span><span class="pre">=&gt;</span></span></span> <span><span><span class="pre">conc</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.left">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">left</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.left" title="Link to this definition">¶</a></dt>
<dd><p>Reduce a goal with a disjunction conclusion into the goal where the
conclusion has been replaced with the first disjunct.
That is, <a class="reference internal" href="#squirrel:tacn.left" title="left"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">left</span></code></a> turns <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span> <span class="pre">|</span><span class="pre">|</span> <span><span><span class="pre">G</span></span></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.right">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">right</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.right" title="Link to this definition">¶</a></dt>
<dd><p>Reduce a goal with a disjunction conclusion into the goal where the
conclusion has been replaced with the second disjunct.
That is, <a class="reference internal" href="#squirrel:tacn.right" title="right"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">right</span></code></a> turns <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span> <span class="pre">|</span><span class="pre">|</span> <span><span><span class="pre">G</span></span></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">Γ</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">G</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.split">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">split</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.split" title="Link to this definition">¶</a></dt>
<dd><p>Split a conjunction goal, creating one sub-goal per conjunct.
For example, <a class="reference internal" href="#squirrel:tacn.split" title="split"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">split</span></code></a> replaces the goal <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span> <span><span><span class="pre">&amp;&amp;</span></span></span> <span><span><span class="pre">G</span></span></span> <span><span><span class="pre">&amp;&amp;</span></span></span> <span><span><span class="pre">H</span></span></span></span></code>
with the three goals <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span></span></code>, <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">G</span></span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">H</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.use">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">use</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">with</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">as</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.use" title="Link to this definition">¶</a></dt>
<dd><p>Instantiate a lemma or hypothesis using the provided arguments (if
any). An introduction pattern can also be specified to handle the
new hypothesis.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This tactic is a deprecated (and less powerful) variant of the
<a class="reference internal" href="#squirrel:tacn.have" title="have"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">have</span></code></a> tactic (with the <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">have</span></span></span> <a class="reference internal" href="#grammar-token-have_ip"><span class="hole"><span class="pre">have_ip</span></span></a> <span><span><span class="pre">:=</span></span></span> <a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code>
form).</p>
</div>
</dd></dl>

</section>
<section id="local-tactics">
<h4>Local tactics<a class="headerlink" href="#local-tactics" title="Link to this heading">¶</a></h4>
<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.true">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">true</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.true" title="Link to this definition">¶</a></dt>
<dd><p>Close a goal when the conclusion is (syntactically) <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">true</span></span></code>.</p>
</dd></dl>

</section>
<section id="global-tactics">
<h4>Global tactics<a class="headerlink" href="#global-tactics" title="Link to this heading">¶</a></h4>
<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.byequiv">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">byequiv</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.byequiv" title="Link to this definition">¶</a></dt>
<dd><p>Transform a global judgement <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">[F]</span></span></span></span></code> into a local judgement
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">F</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.constseq">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">constseq</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a><span><span><span class="pre">:</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">(fun</span></span></span> <a class="reference internal" href="logic.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.constseq" title="Link to this definition">¶</a></dt>
<dd><p>Simplify a sequence at the given <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span></code> when it only
contains a finite number of possible values <code class="squirrelinline docutils literal notranslate"><span><span class="pre">v_1</span></span></code>,…, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">v_i</span></span></code>
depending on the value of the sequence variable.</p>
<p>Given a sequence over a variable of a given type, the arguments
passed must be of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">(fun_1</span> <span class="pre">v_1)</span> <span class="pre">...</span> <span class="pre">(fun_i</span> <span class="pre">v_i)</span></span></code>, where
all the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fun</span></span></code> functions must be binders over the sequence type
and must return a boolean.  This tactic creates two sub-goals
asking to prove the two required properties of the arguments and
sequence:</p>
<ul class="simple">
<li><p>All the functions must be such that for any given input element,
exactly one of the functions returns true.</p></li>
<li><p>The sequence is then expected to be equal to the value of <cite>v_i</cite>
for all input elements such that fun_i is true.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example: Constseq one or zero</p>
<p>Consider the following conclusion for a global goal <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">0</span></span><span><span class="pre">:</span>
</span><span class="ansi-fg-light-green"><span class="pre">seq</span></span><span><span class="pre">(t':</span></span><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span><span><span class="pre">=&gt;(</span></span><span class="ansi-fg-light-blue"><span class="pre">if</span></span><span> <span class="pre">(t'</span> <span class="pre">&lt;</span> <span class="pre">t)</span> </span><span class="ansi-fg-light-blue"><span class="pre">then</span></span><span> <span class="pre">one))</span></span></code> (assuming that
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t'</span></span></code> is a free <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span></code> variable).</p>
<p>It is clear that this sequence only returns <code class="squirrelinline docutils literal notranslate"><span><span class="pre">one</span></span></code> or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">zero</span></span></code> (zero is in the implicit else branch). It can then be
simplified by calling the tactic:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">constseq</span><span> </span><span class="ansi-fg-light-blue">0</span><span>:
</span></dt><dt class="in"><span>  (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; t’ &lt; t) one)
</span></dt><dt class="in"><span>     (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; not (t’ &lt; t)) zero).
</span></dt></dl>
</div>
<p>This replaces in the current goal the constant by zero and one,
and creats two sub-goal, asking to prove the two following formulas:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">forall</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>),
</span></dt><dt class="in"><span>  (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; t’ &lt; t) t’
</span></dt><dt class="in"><span>  || (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; not (t’ &lt; t)) t’
</span></dt></dl>
</div>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>(</span><span class="ansi-fg-light-blue">forall</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>),
</span></dt><dt class="in"><span>   (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; t’ &lt; t) t’ =&gt; </span><span class="ansi-fg-light-blue">if</span><span> (t’ &lt; t) </span><span class="ansi-fg-light-blue">then</span><span> one = one) &amp;&amp;
</span></dt><dt class="in"><span class="ansi-fg-light-blue">forall</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>),
</span></dt><dt class="in"><span>   (</span><span class="ansi-fg-light-blue">fun</span><span> (t’:</span><span class="ansi-fg-light-cyan">timestamp</span><span>) =&gt; not (t’ &lt; t)) t’ =&gt; </span><span class="ansi-fg-light-blue">if</span><span> (t’ &lt; t) </span><span class="ansi-fg-light-blue">then</span><span> one = zero
</span></dt></dl>
</div>
</div>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.enrich">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">enrich</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.enrich" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Enrich the conclusion of an equivalence goal with the given terms.
Note that this changes the positions of items in the equivalence, and
if added before other tactics may break later references.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.localize">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">localize</span></span></span> <span class="hole"><span class="pre">hypothesis</span></span> <span><span><span class="pre">as</span></span></span> <a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.localize" title="Link to this definition">¶</a></dt>
<dd><p>Change a global hypothesis containing a reachability formula
<code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[</span></span></span><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">]</span></span></span></span></code> to a local hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, and applies the
given simple introduction pattern <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-simpl_ip"><span class="hole"><span class="pre">simpl_ip</span></span></a></span></code> to the new hypothesis.</p>
<p>For example, the tactic turns <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">[F],G</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">H</span></span></span></span></code> into <code class="docutils literal notranslate"><span class="notation"><span><span><span class="pre">F,G</span></span></span> <span><span><span class="pre">⊢</span></span></span> <span><span><span class="pre">H</span></span></span></span></code>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.memseq">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">memseq</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.memseq" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Prove that a bi-frame element appears in a sequence of the bi-frame.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.refl">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">refl</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.refl" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Close a goal by reflexivity. Cannot apply if the goal contains
variable or macros, as those may have different left and right
behaviours.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.sym">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">sym</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.sym" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Swap the left and right system of the equivalence goal.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.trans">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">trans</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.trans" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Prove an equivalence by transitivity.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.splitseq">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">splitseq</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a><span><span><span class="pre">:</span></span></span> <span><span><span class="pre">(fun</span></span></span> <a class="reference internal" href="logic.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span><span class="pre">=&gt;</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">)</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.splitseq" title="Link to this definition">¶</a></dt>
<dd><p>Split a sequence according to some boolean test, replacing the
sequence with two subsequences.</p>
<p>The function passed as argument must be take as
argument a variable of the same type as the sequence, and must
return a boolean.</p>
<div class="admonition note">
<p class="admonition-title">Example: Splitting a sequence</p>
<p>Called in a goal with a conclusion of the form <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">0</span></span><span><span class="pre">:</span> </span><span class="ansi-fg-light-green"><span class="pre">seq</span></span><span><span class="pre">(x:</span></span><span class="ansi-fg-light-cyan"><span class="pre">message</span></span><span> <span class="pre">=&gt;</span>
<span class="pre">value)</span></span></code>, the tactic:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">splitseq</span><span> </span><span class="ansi-fg-light-blue">0</span><span>: (</span><span class="ansi-fg-light-blue">fun</span><span> y:</span><span class="ansi-fg-light-cyan">message</span><span> =&gt; some_test)
</span></dt></dl>
</div>
<p>replaces the conclusion with:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">0</span><span>: </span><span class="ansi-fg-light-green">seq</span><span>(x:</span><span class="ansi-fg-light-cyan">message</span><span>=&gt;
</span></dt><dt class="in"><span>         (</span><span class="ansi-fg-light-blue">if</span><span>  (</span><span class="ansi-fg-light-blue">fun</span><span> y:</span><span class="ansi-fg-light-cyan">message</span><span> =&gt; some_test) x </span><span class="ansi-fg-light-blue">then</span><span>
</span></dt><dt class="in"><span>                 value))
</span></dt><dt class="in"><span class="ansi-fg-light-blue">1</span><span>: </span><span class="ansi-fg-light-green">seq</span><span>(x:</span><span class="ansi-fg-light-cyan">message</span><span>=&gt;
</span></dt><dt class="in"><span>         (</span><span class="ansi-fg-light-blue">if</span><span> not ((</span><span class="ansi-fg-light-blue">fun</span><span> y:</span><span class="ansi-fg-light-cyan">message</span><span> =&gt; some_test) x) </span><span class="ansi-fg-light-blue">then</span><span>
</span></dt><dt class="in"><span>                 value))
</span></dt></dl>
</div>
</div>
</dd></dl>

</section>
</section>
<section id="structural-tactics">
<span id="section-structural-tactics"></span><h3>Structural tactics<a class="headerlink" href="#structural-tactics" title="Link to this heading">¶</a></h3>
<section id="id9">
<h4>Common tactics<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h4>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.constraints">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">constraints</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.constraints" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to conclude by automated reasoning on trace literals.
Literals are collected from hypotheses, both local and global,
after the destruction of conjunctions (but no case analysis is
performed to handle conjunctive hypotheses). If the conclusion
is a trace literal then it is taken into account as well.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.depends">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">depends</span></span></span> <span class="hole"><span class="pre">timestamp</span></span><span><span><span class="pre">,</span></span></span> <span class="hole"><span class="pre">timestamp</span></span></span></span><a class="headerlink" href="#squirrel:tacn.depends" title="Link to this definition">¶</a></dt>
<dd><p>If the second action depends on the first action, and if the second
action happens, then add the corresponding timestamp inequality.</p>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Not-dependent">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Not</span></span></span> <span><span><span class="pre">dependent</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Not-dependent" title="Link to this definition">¶</a></dt>
<dd><p>The two actions are not dependent, i.e. were not derived
from two outputs in sequence in the source process.</p>
</dd></dl>

</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.expand">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">expand</span></span></span> <span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-macro_id"><span class="hole"><span class="pre">macro_id</span></span></a> <span class="pre">|</span> <a class="reference internal" href="logic.html#grammar-token-macro_application"><span class="hole"><span class="pre">macro_application</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.expand" title="Link to this definition">¶</a></dt>
<dd><p>Expand all occurences of the given macros in both the conclusion
and proof-context, either fully specified with an action or simply
a type of macro.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.expandall">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">expandall</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.expandall" title="Link to this definition">¶</a></dt>
<dd><p>Expand all possible macros in the current proof-context and conclusion.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.fa">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">fa</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span class="repeat-wrapper-with-sub"><span class="repeat"><a class="reference internal" href="#grammar-token-fa_arg"><span class="hole"><span class="pre">fa_arg</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.fa" title="Link to this definition">¶</a></dt>
<dd><span class="prodn-table"><span class="prodn-column-group"><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span><span class="prodn-column"></span></span><span class="prodn-row-group"><span class="prodn-row"><span class="prodn-cell-nonterminal"><span class="prodn-target"><span class="target" id="grammar-token-fa_arg"></span></span><span class="notation"><a class="reference internal" href="#grammar-token-fa_arg"><span class="hole">fa_arg</span></a></span></span><span class="prodn-cell-op"><code class="docutils literal notranslate"><span class="pre">::=</span></code></span><span class="prodn-cell-production"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span><span>!</span></span></span><span class="alternative-separator">​</span><span class="alternative-block"><span><span>?</span></span></span></span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole">term_pat</span></a></span></span><span class="prodn-cell-tag"><code class="docutils literal notranslate"></code></span></span></span></span><p>Apply the function application rule, simplifying the goal by
removing the head function symbol, as follows:</p>
<ul class="simple">
<li><p>in a local goal with conclusion <code class="squirrelinline docutils literal notranslate"><span><span class="pre">f</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">v</span></span></code>, the conclusion is
replaced with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">u=v</span></span></code>. This produces as many sub-goals as there are arguments
of the head function symbol. For a local goal, the tactic takes no
arguments.</p></li>
<li><p>in a global goal, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">f(u1,...,un)</span></span></code> is replaced with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">u1,...,un</span></span></code>.</p></li>
</ul>
<p>In the global goal setting, the target can be selected with its
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span></code>, or using a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-fa_arg"><span class="hole"><span class="pre">fa_arg</span></span></a></span></code>, which behave as follow:</p>
<ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fa</span></span></code> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code> selects the first position in the equivalence
that matches <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code>.</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fa</span></span><span> <span class="pre">!t</span></span></code> repeats the function application as many times
as possible, but at least once.</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fa</span></span><span> <span class="pre">?t</span></span></code> repeats the function application as many times
as possible, including 0.</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fa</span></span><span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...</span></span></code> is syntactic sugar for
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fa</span></span><span> <span class="pre">arg1;</span> </span><span class="ansi-fg-light-blue"><span class="pre">fa</span></span><span> <span class="pre">arg2;</span> <span class="pre">...</span></span></code>.</p></li>
</ul>
</dd></dl>

</section>
<section id="id11">
<h4>Local tactics<a class="headerlink" href="#id11" title="Link to this heading">¶</a></h4>
<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.congruence">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">congruence</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.congruence" title="Link to this definition">¶</a></dt>
<dd><p>Attempt to conclude by automated reasoning on message (dis)-equalities.
Equalities and disequalities are collected from hypotheses, both local
and global, after the destruction of conjunctions (but no case analysis
is performed to handle conjunctive hypotheses). If the conclusion
is a message (dis)-equality then it is taken into account as well.</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.const">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">const</span></span></span> <a class="reference internal" href="logic.html#grammar-token-variable"><span class="hole"><span class="pre">variable</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.const" title="Link to this definition">¶</a></dt>
<dd><p>Add the <cite>const</cite> tag to a variable.</p>
<p>The variable must be of a finite and fixed (η-independent) type,
and must not appear in any global hypothesis (some global
hypotheses may be localised (see <a class="reference internal" href="#squirrel:tacn.localize" title="localize"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">localize</span></code></a>) if necessary.</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.eqnames">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">eqnames</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.eqnames" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Add index constraints resulting from names equalities,
modulo the known equalities.</p>
<p>If <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n(i)</span> <span class="pre">=</span> <span class="pre">n(j)</span></span></code> then <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span> <span class="pre">=</span> <span class="pre">j</span></span></code>. This is checked on all name
equality entailed by the current context.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.executable">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">executable</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.executable" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Assert that <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;_</span></span></code> implies <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;_</span></span></code> for all previous
timestamps.</p>
<p>Given as input a timestamp <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ts</span></span></code>, this tactic produces two new
sub-goals, requiring to prove that <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">happens</span></span><span><span class="pre">(ts)</span></span></code> holds and that
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;ts</span></span></code> also holds. The fact that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">(</span></span><span class="ansi-fg-light-blue"><span class="pre">forall</span></span><span> <span class="pre">(t:</span></span><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span><span><span class="pre">),</span>
<span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">ts</span> <span class="pre">=&gt;</span> </span><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;t)</span></span></code> is added as a hypothesis to the current goal.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.project">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">project</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.project" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Turn a local goal on a <a class="reference internal" href="declarations.html#term-multi-system"><span class="xref std std-term">multi-system</span></a> into one goal for each
single system in the multi-system.</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.rewrite_equiv">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">rewrite</span></span></span> <span><span><span class="pre">equiv</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">-</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.rewrite_equiv" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Use an equivalence to rewrite a reachability goal.</p>
<p>First, try to resolve <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code> as an equivalence
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span><span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(u,v))</span></span></code>. Then, try to find a context <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C</span></span></code>
that does not contain any <a class="reference internal" href="declarations.html#squirrel:decl.name" title="name"><code class="xref squirrel squirrel-decl docutils literal notranslate"><span class="pre">names</span></code></a>, <a class="reference internal" href="logic.html#term-diff-term"><span class="xref std std-term">diff-terms</span></a>
or <a class="reference internal" href="logic.html#term-macro"><span class="xref std std-term">macro terms</span></a> such that the current local goal <code class="squirrelinline docutils literal notranslate"><span><span class="pre">phi</span></span></code> is
convertible with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[u]</span></span></code>. If such a context is found, the current goal is
is changed to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[v]</span></span></code>.</p>
<p>If a <code class="squirrelinline docutils literal notranslate"><span><span class="pre">-</span></span></code> sign is added in front of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-proof_term"><span class="hole"><span class="pre">proof_term</span></span></a></span></code>, the
rewriting occurs in the other direction, replacing <code class="squirrelinline docutils literal notranslate"><span><span class="pre">v</span></span></code> with
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">u</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Hash rewrite</p>
<p>Consider the following goal.</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>System: default/</span><span class="ansi-fg-light-blue">left</span><span> (equivalences: </span><span class="ansi-fg-light-blue">left</span><span>:default/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:default/</span><span class="ansi-fg-light-blue">right</span><span>)
</span></dt><dt class="in"><span>H: </span><span class="ansi-fg-light-blue">equiv</span><span>(</span><span class="ansi-fg-light-green">diff</span><span>(h (a, k), n), </span><span class="ansi-fg-light-green">diff</span><span>(h (b, k), m))
</span></dt><dt class="in"><span>U: [a &lt;&gt; b]
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span>h (a, k) &lt;&gt; h (b, k)
</span></dt></dl>
</div>
<p>Assuming we have been able to prove that two hashes are
indistinguishable from names, we have hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H</span></span></code>. We
then use <code class="squirrelinline docutils literal notranslate"><span><span class="pre">H</span></span></code> to replace the hashes with names in the conclusion
of the goal, where we want to prove that the two hashes are not equal.</p>
<p>Calling <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">rewrite</span></span><span> </span><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span><span> <span class="pre">H</span></span></code> produces the new goal:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>System: default/</span><span class="ansi-fg-light-blue">right</span><span> (equivalences: </span><span class="ansi-fg-light-blue">left</span><span>:default/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:default/</span><span class="ansi-fg-light-blue">right</span><span>)
</span></dt><dt class="in"><span>H: </span><span class="ansi-fg-light-blue">equiv</span><span>(</span><span class="ansi-fg-light-green">diff</span><span>(h (a, k), n), </span><span class="ansi-fg-light-green">diff</span><span>(h (b, k), m))
</span></dt><dt class="in"><span>U: [a &lt;&gt; b]
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span>n &lt;&gt; m
</span></dt></dl>
</div>
</div>
</div></blockquote>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.smt">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">smt</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">~prover</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">~style</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">~timeout:</span></span></span><a class="reference internal" href="reference-intro.html#grammar-token-natural"><span class="hole"><span class="pre">natural</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.smt" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Try to discharge the current goal using an SMT solver.</p>
<p>The prover called can be chosen using the flag <cite>~prover</cite>, supported provers include
CVC5 (<cite>CVC5</cite>), Z3 (<cite>Z3</cite>) and Alt-Ergo (<cite>AltErgo</cite>).
The alternative counterexamples can be used by adding (<cite>_counterexamples</cite>)
after the name of the prover. The same goes with alternatives (<cite>_BV</cite>) for
Alt-Ergo and (<cite>_noBV</cite>) for Z3.</p>
<p>The time before the timeout can be set with the flag <cite>~timeout</cite> (in seconds).
By default it is 1s.</p>
<p>The theory used to translate timestamps is chosen using the flag <cite>~style</cite>.
We can chose to translate timestamps to integers (<cite>nat</cite>) or to an abstract
type with the usual equality (<cite>abstract</cite>) or not (<cite>abstract_noeq</cite>).</p>
</div></blockquote>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.subst">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">subst</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.subst" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p>If <code class="squirrelinline docutils literal notranslate"><span><span class="pre">x</span> <span class="pre">=</span> <span class="pre">t</span></span></code> where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">x</span></span></code> is a variable, then <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">subst</span></span><span> <span class="pre">x,</span> <span class="pre">t</span></span></code>
substitutes all occurrences of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">x</span></span></code> with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> and removes <code class="squirrelinline docutils literal notranslate"><span><span class="pre">x</span></span></code>
from the <a class="reference internal" href="#term-logical_var"><span class="xref std std-term">logical variables</span></a>.</p>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Unequal-arguments">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Unequal</span></span></span> <span><span><span class="pre">arguments</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Unequal-arguments" title="Link to this definition">¶</a></dt>
<dd><p>Terms given as argument are not equal.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

</section>
<section id="id12">
<h4>Global tactics<a class="headerlink" href="#id12" title="Link to this heading">¶</a></h4>
<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.case_study">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cs</span></span></span> <span class="hole"><span class="pre">pattern</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">in</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.case_study" title="Link to this definition">¶</a></dt>
<dd><p>Performs case study on conditionals inside an equivalence.</p>
<p>Without a specific target, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">cs</span></span><span> <span class="pre">phi</span></span></code> will project all conditionals
on phi in the equivalence. With a specific target, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">cs</span></span><span> <span class="pre">phi</span> </span><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span> <span class="pre">i</span></span></code>
will only project conditionals in the i-th item of the equivalence.</p>
<div class="admonition note">
<p class="admonition-title">Example</p>
<p>When proving an equivalence</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">equiv</span><span>(</span><span class="ansi-fg-light-blue">if</span><span> phi </span><span class="ansi-fg-light-blue">then</span><span> t1 </span><span class="ansi-fg-light-blue">else</span><span> t2, </span><span class="ansi-fg-light-blue">if</span><span> phi </span><span class="ansi-fg-light-blue">then</span><span> u1 </span><span class="ansi-fg-light-blue">else</span><span> u2)
</span></dt></dl>
</div>
<p>invoking <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">cs</span></span><span> <span class="pre">phi</span></span></code> results in two sub-goals:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">equiv</span><span>(phi, t1, u1)
</span></dt><dt class="in"><span class="ansi-fg-light-blue">equiv</span><span>(phi, t2, u2)
</span></dt></dl>
</div>
</div>
<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Argument-of-cs-should-match-a-boolean">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Argument</span></span></span> <span><span><span class="pre">of</span></span></span> <span><span><span class="pre">cs</span></span></span> <span><span><span class="pre">should</span></span></span> <span><span><span class="pre">match</span></span></span> <span><span><span class="pre">a</span></span></span> <span><span><span class="pre">boolean.</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Argument-of-cs-should-match-a-boolean" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="squirrel exn">
<dt class="sig sig-object squirrel" id="squirrel:exn.Did-not-find-any-conditional-to-analyze">
<em class="property"><span class="sigannot"><span class="pre">Error</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">Did</span></span></span> <span><span><span class="pre">not</span></span></span> <span><span><span class="pre">find</span></span></span> <span><span><span class="pre">any</span></span></span> <span><span><span class="pre">conditional</span></span></span> <span><span><span class="pre">to</span></span></span> <span><span><span class="pre">analyze.</span></span></span></span></span><a class="headerlink" href="#squirrel:exn.Did-not-find-any-conditional-to-analyze" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.deduce">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">deduce</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.deduce" title="Link to this definition">¶</a></dt>
<dd><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">deduce</span></span><span> <span class="pre">i</span></span></code> removes the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span></span></code>’th element from the bi-frame when it can
be computed from the rest of the bi-frame. Without any argument, it
will remove the first element that can be dropped, if it
exists.</p>
<p>Here, the fact that the bi-frame element <code class="squirrelinline docutils literal notranslate"><span><span class="pre">u</span></span></code> can be computed
from the other bi-frame elements <code class="squirrelinline docutils literal notranslate"><span><span class="pre">x,y,...</span></span></code> means that there
exists a context <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C</span></span></code> made of function applications such that
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">u</span></span></code> is equal to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[x,y,..]</span></span></code>.</p>
<p>This relies on some heuristical automated reasoning. Some properties on
macros are automatically exploited, e.g. that for any
timestamp <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;pred(t)</span></span></code> allows to deduce
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;t</span></span></code>, all <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t'</span></span></code> for <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t'</span> <span class="pre">&lt;</span> <span class="pre">pred(t)</span></span></code>, as well as
the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;t'</span></span></code> for whenever <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;t'</span></span></code> is true.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.diffeq">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">diffeq</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.diffeq" title="Link to this definition">¶</a></dt>
<dd><p>Close a reflexive goal up to equality. That is, if all diff-term
whitin the global goal’s conclusion always evaluate to the same value in all
systems, the equivalence holds. For each diff-term, a
dedicated sub-goal is created.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This tactic is still at an experimental development
stage. We do not recommend its usage.</p>
</div>
</dd></dl>

</section>
</section>
<section id="cryptographic-tactics">
<span id="section-crypto-tactics"></span><h3>Cryptographic tactics<a class="headerlink" href="#cryptographic-tactics" title="Link to this heading">¶</a></h3>
<p>Cryptographic tactics enable reasoning over cryptographic and
probabilistic properties of random samplings and primitives.</p>
<section id="occurrence-formula">
<h4>Occurrence formula<a class="headerlink" href="#occurrence-formula" title="Link to this heading">¶</a></h4>
<p>Several reasoning techniques require tracking how a given name is
used. For instance, if the name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> does not occur at all in term
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>, then <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n=t</span></span></code> is false with overwhelming probability. To apply
a cryptographic assumption relying on a secret key, one needs to check
that all occurrences of the secret key are valid (i.e. correspond
to the key argument of the corresponding primitive).</p>
<p>Over macro-free terms, collecting occurrences is simply equivalent to
looking at the subterms. However, if some macros occur in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>,
typically <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;ts</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;ts</span></span></code>, we need to look through all
the actions that may have happened before <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ts</span></span></code> to look for
occurrences.</p>
<p>We define here how to build an <span class="term-defn"><span class="target" id="term-occurrence-formula"></span>occurrence formula</span> that will be
reused in several tactics description. For any name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code>, any term
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> and a set of allowed patterns <code class="squirrelinline docutils literal notranslate"><span><span class="pre">pats</span></span></code> (patterns built over
the name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> and function applications), we define the formula
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs(n,t,pats)</span></span></code> as the conjunction of conditions under which it
is possible that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> occurs in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> without following one of the
allowed pattern of <cite>pats</cite>:</p>
<ul class="simple">
<li><p>whenever <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> contains as a subterm an occurrence <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> that does
not match any of the allowed patterns <code class="squirrelinline docutils literal notranslate"><span><span class="pre">pats</span></span></code>, the formula is
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">true</span></span></code>.</p></li>
<li><p>whenever <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> contains a <a class="reference internal" href="declarations.html#section-system-macros"><span class="std std-ref">system-defined
macro</span></a>, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">macro&#64;ts</span></span></code>, if <cite>ts</cite> is a concrete
action, we simply unfold the definition of the macro, and whenever
is it not concrete, we collect all actions of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A1</span></span></code> such
that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> occurs in the definition of the action not as an allowed
pattern, and the formula <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A1&lt;=ts</span></span></code> is added to the conjunction of
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs(n,t,pats)</span></span></code>.</p></li>
</ul>
<p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs</span></span></code> is of course generally defined for indexed names that may
occur in indexed actions.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic name occurrence</p>
<p>Consider the following process:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">name</span><span> n : </span><span class="ansi-fg-light-cyan">index</span><span>-&gt;</span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">channel</span><span> c
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">system</span><span> (!_i !_j A : </span><span class="ansi-fg-light-blue">out</span><span>(c,n(i)) | B :</span><span class="ansi-fg-light-blue">in</span><span>(c,x);</span><span class="ansi-fg-light-blue">out</span><span>(c,x)).
</span></dt></dl>
</div>
<p>The formula <code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs(n(i),</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;B,none)</span></span></code> is equal to <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">exists</span></span><span> <span class="pre">j.</span> <span class="pre">A(i,j)</span> <span class="pre">&lt;</span> <span class="pre">B</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Key corruption</p>
<p>Consider the following process:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">name</span><span> k : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> r : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">senc</span><span> enc,dec.
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">channel</span><span> c.
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">system</span><span> (Corr: </span><span class="ansi-fg-light-blue">out</span><span>(c,k) | B : </span><span class="ansi-fg-light-blue">in</span><span>(c,x);</span><span class="ansi-fg-light-blue">out</span><span>(c,enc(x,r,k))).
</span></dt></dl>
</div>
<p>To reason about the encrypted message, the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> needs to be
secret, and thus the dynamic corruption should not have
happened. This intuition is captured by the formula
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs(k,</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;B,enc(_,r,k))</span></span></code>, which is equal to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">Corr</span> <span class="pre">&lt;</span> <span class="pre">B</span></span></code>.</p>
</div>
<p>This formula may be imprecise, for example due to states.</p>
<div class="admonition note">
<p class="admonition-title">Example: Imprecise state occurrence</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">name</span><span> n : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">mutable</span><span> s = n.
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">channel</span><span> c
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">system</span><span> (A: </span><span class="ansi-fg-light-blue">out</span><span>(c,s) | B :</span><span class="ansi-fg-light-blue">in</span><span>(c,x);</span><span class="ansi-fg-light-blue">out</span><span>(c,x)).
</span></dt></dl>
</div>
<p>Here, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> occurs only inside the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">init</span></span></code> action, where the
mutable state is initialized with value <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code>. The formula
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occurs(n,</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;B,none)</span></span></code> is then equal to <code class="squirrelinline docutils literal notranslate"><span><span class="pre">init</span> <span class="pre">&lt;</span> <span class="pre">B</span></span></code>.
However, the occurrence can happen only if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code> did occur between
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">init</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">B</span></span></code> to reveal the value of the state.</p>
</div>
<p>We define a precise variant <code class="squirrelinline docutils literal notranslate"><span><span class="pre">precise_occurs(n,t,pats)</span></span></code>, that tracks
more precisely the usages of the states, and also adds the condition
that the correct value of the state is revealed if a state can contain
an occurrence of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code>.</p>
<p>We also generalize occur to allow for collecting multiple name
occurrences at once, which is useful when we want to allow patterns depending on
two names at once (see e.g. <a class="reference internal" href="#squirrel:tact.gdh" title="gdh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">gdh</span></code></a> or <a class="reference internal" href="#squirrel:tace.ddh" title="ddh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">ddh</span></code></a>).</p>
</section>
<section id="id15">
<h4>Common tactics<a class="headerlink" href="#id15" title="Link to this heading">¶</a></h4>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.fresh">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">fresh</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">~precise</span></span></span><span><span><span class="pre">_</span></span></span><span><span><span class="pre">ts</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="alternative"><span class="alternative-block"><a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></span></span></span><a class="headerlink" href="#squirrel:tacn.fresh" title="Link to this definition">¶</a></dt>
<dd><p>Fresh is an information-theoretically sound tactic exploiting the
fact that names represent independent random samplings. This can be
exploited in two ways: i) to remove a fresh name from an
equivalence; or ii) to obtain that a term has a negligible
probability of being equal to a fresh name.</p>
<p>In a local goal with conclusion <code class="squirrelinline docutils literal notranslate"><span><span class="pre">phi</span></span></code>,
the tactic may be called on a hypothesis of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t=n</span></span></code> for
some name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> sampled over a type with tag <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">large</span></span></code>.
For such a sampling, if term <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> is computed without knowing <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code>,
this equality can only hold with negligible probability.
We may thus assume that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> occurs in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.
Accordingly, the tactic turns the conclusion
into the formula <code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(n,t,none)</span> <span class="pre">=&gt;</span> <span class="pre">phi</span></span></code> (see the
definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>).</p>
<p>If one can then prove that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> cannot occur in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>, that is
that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(n,t,none)</span></span></code> is false, that new conclusion trivially holds.
If <code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(n,t,none)</span></span></code> is trivially false, e.g. if
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> is a macro-free term without <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> as a subterm, the goal
will be directly closed.</p>
<div class="admonition note">
<p class="admonition-title">Example: Name leak</p>
<p>Consider a small process <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span><span class="pre">(c,x);</span> <span class="pre">A</span> <span class="pre">:</span> </span><span class="ansi-fg-light-blue"><span class="pre">out</span></span><span><span class="pre">(c,x);</span></span><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span><span class="pre">(c,x);</span> <span class="pre">B:</span>
</span><span class="ansi-fg-light-blue"><span class="pre">out</span></span><span><span class="pre">(c,n)</span></span></code>, where we wish to prove that <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;A</span> <span class="pre">&lt;&gt;</span>
<span class="pre">n</span></span></code>. Intuitively, this holds as <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> is only revealed after
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code> has occurred.</p>
<p>The goal corresponding to this proof will look like this:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>System: </span><span class="ansi-fg-light-blue">left</span><span>:default/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:default/</span><span class="ansi-fg-light-blue">right</span><span>
</span></dt><dt class="in"><span>Eq: </span><span class="ansi-fg-light-green">input</span><span>&#64;A = n
</span></dt><dt class="in"><span>H: </span><span class="ansi-fg-light-green">happens</span><span>(A)
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span class="ansi-fg-light-cyan">false</span><span>
</span></dt></dl>
</div>
<p>Calling <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">fresh</span></span><span> <span class="pre">Eq</span></span></code> turns the goal into:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>[goal&gt; Focused goal (</span><span class="ansi-fg-light-blue">1</span><span>/</span><span class="ansi-fg-light-blue">1</span><span>):
</span></dt><dt class="in"><span>System: </span><span class="ansi-fg-light-blue">left</span><span>:default/</span><span class="ansi-fg-light-blue">left</span><span>, </span><span class="ansi-fg-light-blue">right</span><span>:default/</span><span class="ansi-fg-light-blue">right</span><span>
</span></dt><dt class="in"><span>Eq: </span><span class="ansi-fg-light-green">input</span><span>&#64;A = n
</span></dt><dt class="in"><span>H: </span><span class="ansi-fg-light-green">happens</span><span>(A)
</span></dt><dt class="in"><span>—————————————-
</span></dt><dt class="in"><span>B &lt; A =&gt; </span><span class="ansi-fg-light-cyan">false</span><span>
</span></dt></dl>
</div>
<p>Here, Squirrel automatically deduced that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> can only occur
inside <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;A</span></span></code> if the output of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">B</span></span></code> happened before
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code>. One would conclude by using the fact, according to the
process definition, this is impossible.</p>
</div>
<p>In an equivalence goal, on the other hand, the tactic must be applied to a bi-frame
element <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span></span></code> of the form <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(nL,nR)</span></span></code>, where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nL</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nR</span></span></code> are names
sampled over the same type.
Since samplings are independent, the two names are indistinguishable,
unless some information on them is revealed by the rest of the bi-frame.
Note that, contrary to the local case, that property holds even if the type
is not <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">large</span></span></code>.</p>
<p>If we let <code class="squirrelinline docutils literal notranslate"><span><span class="pre">bf</span></span></code> denote the bi-frame, the :g:ì`th
bi-frame element is replaced by the tactic with</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">if</span><span> not(</span><span class="ansi-fg-light-green">diff</span><span>(occur(nL,bf,i : </span><span class="ansi-fg-light-green">diff</span><span>(nL,nR)),occur(nR,bf,i : </span><span class="ansi-fg-light-green">diff</span><span>(nL,nR)))) </span><span class="ansi-fg-light-blue">then</span><span>
</span></dt><dt class="in"><span>  zero
</span></dt><dt class="in"><span class="ansi-fg-light-blue">else</span><span>
</span></dt><dt class="in"><span>  </span><span class="ansi-fg-light-green">diff</span><span>(nL,nR)
</span></dt></dl>
</div>
<p>We specify through the occurrence formula that the only possible
occurrence of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nL</span></span></code> is in fact the one we are currently looking at.</p>
<p>In all cases, the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">precise_ts</span></span></code> makes the tactic use
<cite>precise_occur</cite> instead of <cite>occur</cite>.</p>
<p>Latest formal Squirrel description: <span id="id17">[<a class="reference internal" href="bibliography.html#id6" title="David Baelde, Adrien Koutsos, and Joseph Lallemand. A Higher-Order Indistinguishability Logic for Cryptographic Reasoning. working paper or preprint, 2023. URL: https://hal.inria.fr/hal-03981949.">BKL23</a>]</span> (Appendix F).</p>
</dd></dl>

</section>
<section id="id18">
<h4>Local tactics<a class="headerlink" href="#id18" title="Link to this heading">¶</a></h4>
<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.cdh">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cdh</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.cdh" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the Computational Diffie-Hellman assumption (see
e.g. <span id="id19">[<a class="reference internal" href="bibliography.html#id9" title="Tatsuaki Okamoto and David Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Public Key Cryptography: 4th International Workshop on Practice and Theory in Public Key Cryptosystems, PKC 2001 Cheju Island, Korea, February 13–15, 2001 Proceedings 4, 104–118. Springer, 2001. URL: https://www.di.ens.fr/david.pointcheval/Documents/Papers/2001_pkc.pdf.">OP01</a>]</span>), stating
for a generator <span class="math notranslate nohighlight">\(g\)</span> and randomly sampled exponents <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>,
it is computationally hard to compute <span class="math notranslate nohighlight">\(g^{ab}\)</span>
when only <span class="math notranslate nohighlight">\(g^a\)</span> and <span class="math notranslate nohighlight">\(g^b\)</span> are known.</p>
<p>A <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">cdh</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">ddh</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">gdh</span></span></code>
<a class="reference internal" href="declarations.html#term-group-declaration"><span class="xref std std-term">group declaration</span></a> must have been
specified (the DDH or GDH assumptions indeed both imply the CDH assumption).
For a group with generator <code class="squirrelinline docutils literal notranslate"><span><span class="pre">g</span></span></code> and exponentiation
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">^</span></span></code>, the tactic <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">cdh</span></span><span> <span class="pre">M,</span> <span class="pre">g</span></span></code> may be called in a local goal on
a message equality hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">M</span></span></code> of the form <cite>t=g^{a b}</cite>.
Following the CDH assumption, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">M</span></span></code> can only hold if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>
accesses <code class="squirrelinline docutils literal notranslate"><span><span class="pre">a</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span><span class="pre">b</span></span></code> in some way other than <code class="squirrelinline docutils literal notranslate"><span><span class="pre">g^a</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">g^b</span></span></code>.</p>
<p>Therefore, the tactic will replace in the current goal the conclusion <code class="squirrelinline docutils literal notranslate"><span><span class="pre">phi</span></span></code> with
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(a,t,g^a)</span> <span class="pre">||</span> <span class="pre">occur(b,t,g^b)</span> <span class="pre">=&gt;</span> <span class="pre">phi</span></span></code> (see the
definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>). If both occurrence formulas are
trivially false, then the goal is closed automatically.</p>
<p>A formal description of this tactic has not yet been given in any
published work.</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.gdh">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">gdh</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.gdh" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the Gap Diffie-Hellman assumption (see
e.g. <span id="id20">[<a class="reference internal" href="bibliography.html#id9" title="Tatsuaki Okamoto and David Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Public Key Cryptography: 4th International Workshop on Practice and Theory in Public Key Cryptosystems, PKC 2001 Cheju Island, Korea, February 13–15, 2001 Proceedings 4, 104–118. Springer, 2001. URL: https://www.di.ens.fr/david.pointcheval/Documents/Papers/2001_pkc.pdf.">OP01</a>]</span>), which is similar to CDH over <span class="math notranslate nohighlight">\(g^a\)</span>
and <span class="math notranslate nohighlight">\(g^b\)</span>, except that the attacker is additionally allowed to access an oracle
testing equality to <span class="math notranslate nohighlight">\(g^{ab}\)</span>. It also includes the Square-GDH
variant (see <span id="id21">[<a class="reference internal" href="bibliography.html#id10" title="Atsushi Fujioka and Koutarou Suzuki. Designing efficient authenticated key exchange resilient to leakage of ephemeral secret keys. In Topics in Cryptology–CT-RSA 2011: The Cryptographers’ Track at the RSA Conference 2011, San Francisco, CA, USA, February 14-18, 2011. Proceedings, 121–141. Springer, 2011.">FS11</a>]</span>), which is equivalent to the GDH
assumption for prime order groups, where the attacker can also test
equality to <span class="math notranslate nohighlight">\(g^{aa}\)</span> and <span class="math notranslate nohighlight">\(g^{bb}\)</span>.</p>
<p>A <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">gdh</span></span></code> <a class="reference internal" href="declarations.html#term-group-declaration"><span class="xref std std-term">group declaration</span></a> must have been
specified.</p>
<p>The behaviour of this tactic is similar to <a class="reference internal" href="#squirrel:tact.cdh" title="cdh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">cdh</span></code></a>, expect that
the current goal’s conclusion <code class="squirrelinline docutils literal notranslate"><span><span class="pre">phi</span></span></code> is replaced with a more permissive formula
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur((a,b),t,(g^a,g^b,_=g^(ab),</span> <span class="pre">_=g^(bb),</span> <span class="pre">_=g^(aa))</span> <span class="pre">=&gt;</span> <span class="pre">phi</span></span></code>
(see the definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>).</p>
<p>A formal description of this tactic has not yet been given in any
published work.</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.collision">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">collision</span></span></span></span></span><a class="headerlink" href="#squirrel:tact.collision" title="Link to this definition">¶</a></dt>
<dd><p>Requires a <a class="reference internal" href="declarations.html#term-hash-function"><span class="xref std std-term">hash function declaration</span></a>.</p>
<p>This tactic applies the known-key collision resistance assumption
(see e.g. the cr2-kk assumption from
<span id="id22">[<a class="reference internal" href="bibliography.html#id8" title="Shafi Goldwasser and Mihir Bellare. Lecture notes on cryptography. Summer course “Cryptography and computer security” at MIT, 1999:1999, 1996. URL: https://cseweb.ucsd.edu/~mihir/papers/gb.pdf.">GB96</a>]</span>).</p>
<p>It collects all equalities between hashes occurring at top-level in
message hypotheses, that is all hypotheses of the form
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(u,k)=h(v,k)</span></span></code>, and for each such hypothesis adds as new
hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">u=v</span></span></code>.</p>
<p>As this implements the known-key variant of the collision resistance assumption,
no side condition is checked on the hash key.</p>
<p>Latest formal Squirrel description: <span id="id23">[<a class="reference internal" href="bibliography.html#id6" title="David Baelde, Adrien Koutsos, and Joseph Lallemand. A Higher-Order Indistinguishability Logic for Cryptographic Reasoning. working paper or preprint, 2023. URL: https://hal.inria.fr/hal-03981949.">BKL23</a>]</span> (only as an example).</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.euf">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">euf</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.euf" title="Link to this definition">¶</a></dt>
<dd><p>Requires either a <a class="reference internal" href="declarations.html#term-hash-function"><span class="xref std std-term">hash function</span></a> or a <a class="reference internal" href="declarations.html#term-signature-scheme"><span class="xref std std-term">signature
scheme</span></a> declaration.</p>
<p>This tactic applies the EUF-CMA axiom in a local goal, either for keyed-hashes or
signatures. (see e.g. <span id="id24">[<a class="reference internal" href="bibliography.html#id8" title="Shafi Goldwasser and Mihir Bellare. Lecture notes on cryptography. Summer course “Cryptography and computer security” at MIT, 1999:1999, 1996. URL: https://cseweb.ucsd.edu/~mihir/papers/gb.pdf.">GB96</a>]</span>)</p>
<p>For a hash function <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(x,k)</span></span></code>, one may call <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span><span> <span class="pre">M</span></span></code> over a
message equality <code class="squirrelinline docutils literal notranslate"><span><span class="pre">M</span></span></code> of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">h(m,k)</span></span></code> or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(m,k)=t</span></span></code>. EUF-CMA then states that, provided
the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> is always used in correct position,
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">M</span></span></code> can only hold if computing <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> requires already knowing the hash of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code>.
Accordingly, the tactic creates a first new sub-goal asking
to prove that the key is only used in correct position, i.e.
a sub-goal with conclusion <code class="squirrelinline docutils literal notranslate"><span><span class="pre">not(occur(k,goal,h(_,k))</span></span></code> (see the
definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>).
The tactic then collects all possible occurrence of a honest hash <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(u,k)</span></span></code> inside
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>, and for each of them, creates a sub-goal with the original conclusion
and a new hypothesis stating that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m=u</span></span></code>. Moreover, if the occurrence is
under a macro, additional new hypotheses will state that these macros must be taken
at an earlier timestamp than <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic hashing</p>
<p>Consider the following system:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">hash</span><span> h
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> k:</span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">channel</span><span> c
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> n : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> m : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">system</span><span> (!_i </span><span class="ansi-fg-light-blue">out</span><span>(c,h(n,k)) | </span><span class="ansi-fg-light-blue">in</span><span>(c,x);</span><span class="ansi-fg-light-blue">out</span><span>(c,x)).
</span></dt></dl>
</div>
<p>Calling <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span></code> over a hypothesis of the form <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;tau</span> <span class="pre">&lt;&gt;</span>
<span class="pre">h(m,k)</span></span></code> would add the fact that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(m,k)</span></span></code> needs to be equal
to one of the honestly computed hashes appearing in
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;tau</span></span></code>, which are all of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(n,k)</span></span></code>. The new
hypothesis would then be:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>(</span><span class="ansi-fg-light-blue">exists</span><span> (i:</span><span class="ansi-fg-light-cyan">index</span><span>), A(i) &lt; tau &amp;&amp; m = n)
</span></dt></dl>
</div>
</div>
<p>For a signature function <code class="squirrelinline docutils literal notranslate"><span><span class="pre">sign(x,r,k)</span></span></code>, public key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">pk(k)</span></span></code>
and verification function <code class="squirrelinline docutils literal notranslate"><span><span class="pre">check(s,m,pub)</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span></code> must be called
on a hypothesis of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">check(s,m,pk(k))</span></span></code>. The behaviour
is then similar to the hash case: honest signatures that may occur
in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">s</span></span></code> will be collected, and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> must be equal to one of the
honestly signed messages. A sub-goal for each possible honest signing
case is created, as well as a sub-goal specifying that the key is
correctly used, i.e. with conclusion
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">not(occur(k,goal,sign(_,k),</span> <span class="pre">pk(k))</span></span></code>.</p>
<p>Latest formal Squirrel description: <span id="id25">[<a class="reference internal" href="bibliography.html#id6" title="David Baelde, Adrien Koutsos, and Joseph Lallemand. A Higher-Order Indistinguishability Logic for Cryptographic Reasoning. working paper or preprint, 2023. URL: https://hal.inria.fr/hal-03981949.">BKL23</a>]</span>.</p>
</dd></dl>

<dl class="squirrel tact">
<dt class="sig sig-object squirrel" id="squirrel:tact.intctxt">
<em class="property"><span class="sigannot"><span class="pre">TraceTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">intctxt</span></span></span> <a class="reference internal" href="#grammar-token-hypothesis_id"><span class="hole"><span class="pre">hypothesis_id</span></span></a></span></span><a class="headerlink" href="#squirrel:tact.intctxt" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the INT-CTXT assumption (see
e.g. <span id="id26">[<a class="reference internal" href="bibliography.html#id11" title="Mihir Bellare and Chanathip Namprempre. Authenticated encryption: relations among notions and analysis of the generic composition paradigm. In International Conference on the Theory and Application of Cryptology and Information Security, 531–545. Springer, 2000. URL: https://eprint.iacr.org/2000/025.pdf.">BN00</a>]</span>) in a local goal.</p>
<p>It requires the declaration of a <a class="reference internal" href="declarations.html#term-symmetric-encryption"><span class="xref std std-term">symmetric encryption</span></a> scheme.</p>
<p>It can be applied to a hypothesis either of the form
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">dec(c,k)&lt;&gt;fail</span></span></code> or <code class="squirrelinline docutils literal notranslate"><span><span class="pre">dec(c,k)</span> <span class="pre">=</span> <span class="pre">t</span></span></code> (in the latter case,
it will generate as an additional proof obligation that <cite>t &lt;&gt; fail</cite>).</p>
<p>The INT-CTXT assumption then states that, provided the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code>
is correctly used, such a decryption may only succeed if
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">c</span></span></code> was produced by an honest encryption.</p>
<p>In both cases, Squirrel will thus collect all honest encryptions made
with key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code>, and produce a subogal corresponding to each case
where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">c</span></span></code> is equal to one of those honest encryptions.</p>
<p>The key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> must only be used in key position, so a sub-goal
asking to prove that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">not(occur(k,c,(enc(_,_,k),dec(_,k)))</span></span></code> is
created when it is not trivially true (see the definition of the
<a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>).</p>
<p>In addition, a goal asking to prove that all randomness used for
encryption are disjoint and fresh (when it is not trivially true).</p>
<p>Latest formal Squirrel description: <span id="id27">[<a class="reference internal" href="bibliography.html#id3" title="David Baelde, Stéphanie Delaune, Charlie Jacomme, Adrien Koutsos, and Solène Moreau. An Interactive Prover for Protocol Verification in the Computational Model. In SP 2021 - 42nd IEEE Symposium on Security and Privacy, Proceedings of the 42nd IEEE Symposium on Security and Privacy (S&amp;P'21). San Fransisco / Virtual, United States, May 2021. URL: https://hal.science/hal-03172119.">BDJ+21</a>]</span>.</p>
</dd></dl>

</section>
<section id="id28">
<h4>Global tactics<a class="headerlink" href="#id28" title="Link to this heading">¶</a></h4>
<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.cca1">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">cca1</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a></span></span><a class="headerlink" href="#squirrel:tace.cca1" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the IND-CCA assumption (see
e.g. <span id="id29">[<a class="reference internal" href="bibliography.html#id11" title="Mihir Bellare and Chanathip Namprempre. Authenticated encryption: relations among notions and analysis of the generic composition paradigm. In International Conference on the Theory and Application of Cryptology and Information Security, 531–545. Springer, 2000. URL: https://eprint.iacr.org/2000/025.pdf.">BN00</a>]</span>) in a global goal.</p>
<p>It requires the declaration of a <a class="reference internal" href="declarations.html#term-symmetric-encryption"><span class="xref std std-term">symmetric encryption</span></a> or
<a class="reference internal" href="declarations.html#term-asymmetric-encryption"><span class="xref std std-term">asymmetric encryption</span></a> scheme.</p>
<p>The tactic may be called over a bi-frame element containing a term of
the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[enc(n,</span> <span class="pre">r,</span> <span class="pre">m)]</span></span></code>, where</p>
<ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">r</span></span></code> must be a fresh name;</p></li>
<li><p>there is no decryption in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C</span></span></code>;</p></li>
<li><p>no universal message variable occurs;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> is  a key  or a public key that
only appears in key position, i.e. under <code class="squirrelinline docutils literal notranslate"><span><span class="pre">pk</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">dec</span></span></code> or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">enc</span></span></code>.</p></li>
</ul>
<p>The tactic will then replace the encryption occurrence by an
encryption of a bitstring of zeroes of the correct length,
yielding <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[enc(zeroes(</span></span><span class="ansi-fg-light-green"><span class="pre">len</span></span><span><span class="pre">(n)),</span> <span class="pre">r,</span> <span class="pre">pk(k))]</span></span></code>.</p>
<p>In addition, the tactic creates a sub-goal asking to prove that all
occurrences of the key and encryptions are correct. Notably, one
must prove that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(k,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,(enc(_,_,k),</span> <span class="pre">dec(_,k))</span></span></code> (see
the definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>) is false (or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(k,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,(pk(k),</span> <span class="pre">dec(_,k))</span></span></code>) for the asymmetric case).</p>
<p>In addition, in the asymmetric case, a sub-goal is created to prove the
freshness of the random used in the encryption, with the conclusion
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(r,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,enc(n,r,m))</span></span></code>.</p>
<p>In the symmetric case, an additional sub-goal is created ensuring
that all encryptions are made with distinct fresh randoms (and not
just the the encryption we are looking at).</p>
<p>Latest formal Squirrel description:<span id="id30">[<a class="reference internal" href="bibliography.html#id6" title="David Baelde, Adrien Koutsos, and Joseph Lallemand. A Higher-Order Indistinguishability Logic for Cryptographic Reasoning. working paper or preprint, 2023. URL: https://hal.inria.fr/hal-03981949.">BKL23</a>]</span>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.ddh">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">ddh</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></span><a class="headerlink" href="#squirrel:tace.ddh" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the Decisional Diffie-Helman assumption (see
e.g. <span id="id31">[<a class="reference internal" href="bibliography.html#id9" title="Tatsuaki Okamoto and David Pointcheval. The gap-problems: a new class of problems for the security of cryptographic schemes. In Public Key Cryptography: 4th International Workshop on Practice and Theory in Public Key Cryptosystems, PKC 2001 Cheju Island, Korea, February 13–15, 2001 Proceedings 4, 104–118. Springer, 2001. URL: https://www.di.ens.fr/david.pointcheval/Documents/Papers/2001_pkc.pdf.">OP01</a>]</span>), stating that for a generator <span class="math notranslate nohighlight">\(g\)</span>,
and randomly sampled exponents <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, it
is computationally hard to distinguish <span class="math notranslate nohighlight">\(g^{ab}\)</span> from <span class="math notranslate nohighlight">\(g^c\)</span>,
when only <span class="math notranslate nohighlight">\(g^a\)</span> and <span class="math notranslate nohighlight">\(g^b\)</span> are known.</p>
<p>A <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">ddh</span></span></code> <a class="reference internal" href="declarations.html#term-group-declaration"><span class="xref std std-term">group declaration</span></a> must have been
specified.</p>
<p>When calling, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">ddh</span></span><span> <span class="pre">g,a,b,k</span></span></code>, the goal must contain only diff
terms of the form <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(g^(ab),g^(c)))</span></span></code>. The tactic will close
the goal if the formula
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur((a,b,c),goal,(g^a,g^b,</span></span><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(g^(ab),c)))</span></span></code> instantly reduces
to false (see the definition of the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>).</p>
<p>Latest formal Squirrel description: <span id="id32">[<a class="reference internal" href="bibliography.html#id3" title="David Baelde, Stéphanie Delaune, Charlie Jacomme, Adrien Koutsos, and Solène Moreau. An Interactive Prover for Protocol Verification in the Computational Model. In SP 2021 - 42nd IEEE Symposium on Security and Privacy, Proceedings of the 42nd IEEE Symposium on Security and Privacy (S&amp;P'21). San Fransisco / Virtual, United States, May 2021. URL: https://hal.science/hal-03172119.">BDJ+21</a>]</span>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.enckp">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">enckp</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="logic.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.enckp" title="Link to this definition">¶</a></dt>
<dd><p>ENC-KP assumes that a symmetric or an asymmetric encryption scheme
does not leak any information about the public (or secret) key
used to encrypt the plaintext. It is based on the IK-CPA notion of
<span id="id33">[<a class="reference internal" href="bibliography.html#id7" title="Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-privacy in public-key encryption. In International Conference on the Theory and Application of Cryptology and Information Security, 566–582. Springer, 2001. URL: https://iacr.org/archive/asiacrypt2001/22480568.pdf.">BBDP01</a>]</span>.</p>
<p>The tactic can be called on a bi-frame element containing a term of
the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C[enc(n,</span> <span class="pre">r,</span> <span class="pre">m)]</span></span></code>, where</p>
<ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">r</span></span></code> must be a fresh name;</p></li>
<li><p>there is no decryption in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">C</span></span></code>;</p></li>
<li><p>no universal message variable occurs;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> is either a key or the diff of two keys, that
only appear in key position, i.e. under <code class="squirrelinline docutils literal notranslate"><span><span class="pre">pk</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">dec</span></span></code> or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">enc</span></span></code>;</p></li>
<li><p>if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> is a key, and a second key has been given as argument to the
tactic, that key must also occur only in key position.</p></li>
</ul>
<p>When <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> is the diff of two keys, the diff is simplified by keeping
only the key on the left. When <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> is just one key, a new key with
which it is replaced can be specified as arugment.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic ENC-KP application</p>
<p>On a bi-frame element of the form</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i : enc(n,r,</span><span class="ansi-fg-light-green">diff</span><span>(pk(k1),pk(k2)))
</span></dt></dl>
</div>
<p>calling the tactic <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">enckp</span></span><span> <span class="pre">i</span></span></code> will simplify the bi-frame
element by only keeping the key on the left, yielding</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i: enc(n,r,pk(k1))
</span></dt></dl>
</div>
</div>
<p>The tactic expects as arguments:</p>
<ul class="simple">
<li><p>the position identifying the bi-frame element;</p></li>
<li><p>optional: the encryption term on which to apply the tactic;</p></li>
<li><p>optional: the new key with which to replace the key.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Example: Switching key with ENC-KP</p>
<p>On a bi-frame element of the form</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i: enc(n,r,m)
</span></dt></dl>
</div>
<p>the tactic <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">enckp</span></span><span> <span class="pre">i,</span> <span class="pre">k</span></span></code> will simplify the bi-frame element by using the specified
key, yielding</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i: enc(n,r,pk(k))
</span></dt></dl>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Example: Targeted ENC-KP application</p>
<p>On a bi-frame element of the form</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i: </span><span class="ansi-fg-light-cyan">⟨</span><span> enc(n,r,m),m’</span><span class="ansi-fg-light-cyan">⟩</span><span>
</span></dt></dl>
</div>
<p>the tactic <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">enckp</span></span><span> <span class="pre">i,enc(n,r,m),</span> <span class="pre">k</span></span></code> will simplify the bi-frame
element by using the specified key, yielding</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span>i: </span><span class="ansi-fg-light-cyan">⟨</span><span> enc(n,r,pk(k)),m </span><span class="ansi-fg-light-blue">‘</span><span class="ansi-fg-light-cyan">⟩</span><span>
</span></dt></dl>
</div>
</div>
<p>To apply the enckp tactic, the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> must be such that
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(k,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,(enc(_,_,k),</span> <span class="pre">dec(_,k))</span></span></code> (see the definition of
the <a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>) is trivially false. (or
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(k,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,(pk(k),</span> <span class="pre">dec(_,k))</span></span></code>) for the asymmetric case).</p>
<p>When it is not trivially true, a sub-goal is created, asking to prove the
freshness of the random used in the encryption, with the conclusion
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(r,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,enc(n,r,m))</span></span></code>.</p>
<p>In the symmetric case, an additional check is performed ensuring
that all encryptions are made with distinct fresh randoms (and not
just the encryption we are looking at).</p>
<p>Latest formal Squirrel description:<span id="id34">[<a class="reference internal" href="bibliography.html#id3" title="David Baelde, Stéphanie Delaune, Charlie Jacomme, Adrien Koutsos, and Solène Moreau. An Interactive Prover for Protocol Verification in the Computational Model. In SP 2021 - 42nd IEEE Symposium on Security and Privacy, Proceedings of the 42nd IEEE Symposium on Security and Privacy (S&amp;P'21). San Fransisco / Virtual, United States, May 2021. URL: https://hal.science/hal-03172119.">BDJ+21</a>]</span>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.prf">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">prf</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.prf" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the PRF assumption (see
e.g. <span id="id35">[<a class="reference internal" href="bibliography.html#id8" title="Shafi Goldwasser and Mihir Bellare. Lecture notes on cryptography. Summer course “Cryptography and computer security” at MIT, 1999:1999, 1996. URL: https://cseweb.ucsd.edu/~mihir/papers/gb.pdf.">GB96</a>]</span>).</p>
<p>It requires a <a class="reference internal" href="declarations.html#term-hash-function"><span class="xref std std-term">hash function</span></a> declaration.</p>
<p>This tactic applied to a bi-frame element containg a hash
application <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(m,k)</span></span></code> tries to replace the hash value with a fresh
name, under the condition that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> has never been hashed before,
and that the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> is correctly used.</p>
<p>Formally, when called over a bi-frame element <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span> <span class="pre">:</span> <span class="pre">C[h(m,k)]</span></span></code>,
the tactic replaces in the current goal the element with <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span> <span class="pre">:</span>
<span class="pre">C[nPRF]</span></span></code> where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nPRF</span></span></code> is a newly generated unique name. It in
addition produces sub-goals requiring to prove the side
conditions described above. It notably produces a goal asking to prove that the key
is only used in key position, i.e. that
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">occur(k,bi-</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">,h(_,k))</span></span></code> is false (see the definition of the
<a class="reference internal" href="#term-occurrence-formula"><span class="xref std std-term">occurrence formula</span></a>). In addition, it creates for each
occurrence of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">h(t,k)</span></span></code> within the bi-frame (that may occur under
macros) a sub-goal asking to prove that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">&lt;&gt;</span> <span class="pre">m</span></span></code>, that is, that
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">m</span></span></code> was never hashed before. Such sub-goals may need to be
created separately for both projections of the bi-frame.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic PRF application</p>
<p>Consider the following system:</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">channel</span><span> c
</span></dt><dt class="in"><span class="ansi-fg-light-blue">hash</span><span> h
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> k : </span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> n :</span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> m :</span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">name</span><span> p :</span><span class="ansi-fg-light-cyan">message</span><span>
</span></dt><dt class="in"><span class="ansi-fg-light-blue">system</span><span> (A: </span><span class="ansi-fg-light-blue">out</span><span>(c,h(n,k)) | B: </span><span class="ansi-fg-light-blue">out</span><span>(c,h(m,k))).
</span></dt></dl>
</div>
<p>When trying to prove that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">[</span></span><span class="ansi-fg-light-green"><span class="pre">happens</span></span><span><span class="pre">(A)]</span> <span class="pre">-&gt;</span>
</span><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span><span><span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;pred(A),</span></span><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;A,p))</span></span></code>, one may call the tactic
prf on the bi-frame element corresponding to the
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;A,p)</span></span></code>, which after expanding output is
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(h(n,k),p)</span></span></code>.</p>
<p>This replaces in the current goal the hash occurrence with
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(n_PRf,p)</span></span></code>, and creates a sub-goal asking to prove that
the hash message <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> is different from any possible
previously hashed message. Here, the only other possible hash
would occur in <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;pred(A)</span></span></code>, in the output of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">B</span></span></code> if it
occurred before <code class="squirrelinline docutils literal notranslate"><span><span class="pre">A</span></span></code>. The created sub-goal then asks to prove
that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">[B</span> <span class="pre">&lt;</span> <span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">n</span> <span class="pre">&lt;&gt;</span> <span class="pre">m]</span></span></code>.</p>
</div>
<p>If multiple occurrences of hashes occur in the bi-frame element, the
first one is targeted by default. Calling the tactic with an
optional <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></code> allows to target a specific hash occurrence.</p>
<p>Latest formal Squirrel description: <span id="id36">[<a class="reference internal" href="bibliography.html#id6" title="David Baelde, Adrien Koutsos, and Joseph Lallemand. A Higher-Order Indistinguishability Logic for Cryptographic Reasoning. working paper or preprint, 2023. URL: https://hal.inria.fr/hal-03981949.">BKL23</a>]</span>.</p>
</dd></dl>

<dl class="squirrel tace">
<dt class="sig sig-object squirrel" id="squirrel:tace.xor">
<em class="property"><span class="sigannot"><span class="pre">EquivTactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">xor</span></span></span> <a class="reference internal" href="#grammar-token-position"><span class="hole"><span class="pre">position</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span><span><span class="pre">,</span></span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tace.xor" title="Link to this definition">¶</a></dt>
<dd><p>This tactic applies the unconditionally sound one time pad property
of the xor operation.</p>
<p>The tactic applied to a bi-frame element of the form <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i</span> <span class="pre">:</span> <span class="pre">C[n</span> <span class="pre">XOR</span>
<span class="pre">t]</span></span></code> will replace the XOR term by</p>
<div class="squirreltop literal-block docutils container">
<dl class="simple">
<dt class="in"><span class="ansi-fg-light-blue">if</span><span> occur(n,bi-</span><span class="ansi-fg-light-green">frame</span><span>, i : C[n XOR t] ) &amp;&amp; </span><span class="ansi-fg-light-green">len</span><span>(n) = </span><span class="ansi-fg-light-green">len</span><span>(t) </span><span class="ansi-fg-light-blue">then</span><span> n_FRESH </span><span class="ansi-fg-light-blue">else</span><span> (n XOR t)
</span></dt></dl>
</div>
<p>This new term then allows us to drop the old term only if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> and
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> do have the same length (as the one time pad does not work otherwise),
and if this is the only occurrence of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> in the
bi-frame.</p>
<p>When multiple XOR occur in the bi-frame, one can specify one or two
optional term patterns, to specify in any order the name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> or
the full XOR-ed term <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span> <span class="pre">XOR</span> <span class="pre">t</span></span></code> to target.</p>
<p>Latest formal Squirrel description: <span id="id37">[<a class="reference internal" href="bibliography.html#id3" title="David Baelde, Stéphanie Delaune, Charlie Jacomme, Adrien Koutsos, and Solène Moreau. An Interactive Prover for Protocol Verification in the Computational Model. In SP 2021 - 42nd IEEE Symposium on Security and Privacy, Proceedings of the 42nd IEEE Symposium on Security and Privacy (S&amp;P'21). San Fransisco / Virtual, United States, May 2021. URL: https://hal.science/hal-03172119.">BDJ+21</a>]</span>.</p>
</dd></dl>

</section>
</section>
<section id="utility-tactics">
<span id="section-utility-tactics"></span><h3>Utility tactics<a class="headerlink" href="#utility-tactics" title="Link to this heading">¶</a></h3>
<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.help">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">help</span></span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeated-alternative"><span class="alternative-block"><span class="hole"><span class="pre">tacn</span></span></span><span class="alternative-separator"><span class="pre">​</span></span><span class="alternative-block"><span><span><span class="pre">concise</span></span></span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.help" title="Link to this definition">¶</a></dt>
<dd><p>When used without arguments, display all available commands.
The tactic can  also display the details for a given tactic name, or display or
more concise list. It is a tactic and not a command, and as such can only
be used inside proofs.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.lemmas">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">lemmas</span></span></span></span></span><a class="headerlink" href="#squirrel:tacn.lemmas" title="Link to this definition">¶</a></dt>
<dd><p>Print all axioms and proved lemmas. This is useful to know which lemmas can
be used through the <a class="reference internal" href="#squirrel:tacn.use" title="use"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">use</span></code></a> or <a class="reference internal" href="#squirrel:tacn.apply" title="apply"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactics.</p>
</dd></dl>

<dl class="squirrel tacn">
<dt class="sig sig-object squirrel" id="squirrel:tacn.show">
<em class="property"><span class="sigannot"><span class="pre">Tactic</span></span></em> <span class="sig-name descname"><span class="notation"><span><span><span class="pre">show</span></span></span> <a class="reference internal" href="#grammar-token-term_pat"><span class="hole"><span class="pre">term_pat</span></span></a></span></span><a class="headerlink" href="#squirrel:tacn.show" title="Link to this definition">¶</a></dt>
<dd><p>Print the messages given as argument. Can be used to print the values
matching a pattern.</p>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="declarations.html" class="btn btn-neutral float-left" title="Declarations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="commands.html" class="btn btn-neutral float-right" title="Commands" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Squirrel developpers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>