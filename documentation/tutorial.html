<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Protocol modelling &mdash; Squirrel  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
    <link rel="stylesheet" type="text/css" href="_static/ansi.css" />
    <link rel="stylesheet" type="text/css" href="_static/notations.css" />
    <link rel="stylesheet" type="text/css" href="_static/pre-text.css" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/rtd_sphinx_search.min.css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/notations.js"></script>
        <script src="_static/js/rtd_search_config.js"></script>
        <script src="_static/js/rtd_sphinx_search.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Indexes" href="appendix/indexes/index.html" />
    <link rel="prev" title="Commands" href="commands.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Squirrel
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference-intro.html">Notations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="reference-intro.html#lexical-conventions">Lexical conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="reference-intro.html#infix-operators">Infix operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="logic.html">Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="logic.html#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#base-types">Base types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#type-variables-and-polymorphism">Type variables and polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#general-types">General types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#binders-and-tags">Binders and tags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#terms-with-binders">Terms with binders</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#multi-terms">Multi-terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#diff-terms">Diff-terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#macros">Macros</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#formulas">Formulas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#local-formulas">Local formulas</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#global-formulas">Global formulas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarations.html">Declarations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#names">Names</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#abstract-functions">Abstract functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#operators">Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#built-ins">Built-ins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#cryptographic-functions">Cryptographic functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#processes">Processes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#channels">Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#memory-cells">Memory cells</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#id4">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#systems-and-actions">Systems and actions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-defined-macros">System-defined macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-expressions">System expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-contexts">System contexts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#axioms-and-lemmas">Axioms and Lemmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proofs.html">Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#judgements">Judgements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#logical-variables">Logical variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#hypotheses">Hypotheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#local-judgement">Local judgement</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#global-judgement">Global judgement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#generalities">Generalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#tactic-arguments">Tactic arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#intro-patterns">Intro patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#proof-terms">Proof terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#proof-term-resolution">Proof-term resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#reduction">Reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#automatic-simplification-tactics">Automatic simplification tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#common-errors">Common errors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#id4">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#generic-tactics">Generic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#common-tactics">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#local-tactics">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#global-tactics">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#structural-tactics">Structural tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id9">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id11">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id12">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#cryptographic-tactics">Cryptographic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#occurrence-formula">Occurrence formula</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id15">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id18">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id28">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#utility-tactics">Utility tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Protocol modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-assumption">Basic assumption</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cryptographic-assumptions">Cryptographic assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#protocols">Protocols</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#reachability-properties">Reachability properties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formulas">Formulas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#equivalence-properties">Equivalence properties</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-declindex.html">Declaration index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="doc-writing.html">Documenting Squirrel with Sphinx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#todo-list-generation">TODO list generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-objects">Squirrel objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#objects">Objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-directives">Squirrel directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-roles">Squirrel roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#common-mistakes">Common mistakes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#improper-nesting">Improper nesting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-token">Overusing <code class="docutils literal notranslate"><span class="pre">:token:</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#omitting-annotations">Omitting annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#using-the-squirreltop-directive-for-syntax-highlighting">Using the <code class="docutils literal notranslate"><span class="pre">..</span> <span class="pre">squirreltop::</span></code> directive for syntax highlighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-plain-quotes">Overusing plain quotes</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-the-example-directive">Overusing the <code class="docutils literal notranslate"><span class="pre">example</span></code> directive</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#tips-and-tricks">Tips and tricks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#nested-lemmas">Nested lemmas</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#abbreviations-and-macros">Abbreviations and macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#advanced-uses-of-notations">Advanced uses of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Squirrel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Protocol modelling</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/squirrel-prover/squirrel-prover/blob/master/documentation/sphinx/source/tutorial.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<span class="target" id="tutorial"></span><p>This tutorial provides a very quick introduction to the main concepts
of <strong>Squirrel</strong>. It can be used to ease its discovery and to get an
intuitive grasp of the multiple concepts by going through a concrete
example. The reference manual provides a more extensive presentation
of all the concepts.</p>
<p>In many cases, the concept introduced here are also direct clickable
references to the more extensive presentation in the reference manual.</p>
<section id="protocol-modelling">
<h1>Protocol modelling<a class="headerlink" href="#protocol-modelling" title="Permalink to this heading">Â¶</a></h1>
<p>Squirrel allows performing proofs of security for communication
protocols relying on cryptography. It works within a high-order logic,
and a first step is to be able to model all the components of a
protocol inside a logic.</p>
<section id="messages">
<h2>Messages<a class="headerlink" href="#messages" title="Permalink to this heading">Â¶</a></h2>
<p>Messages computed by a protocol and sent over the
network are modelled using <a class="reference internal" href="logic.html#term-term"><span class="std std-ref">terms</span></a>.</p>
<p>Concretely, a term is built from</p>
<blockquote>
<div><ul class="simple">
<li><p>a name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> used to model a random sampling;</p></li>
<li><p>applications of functions <code class="squirrelinline docutils literal notranslate"><span><span class="pre">f(m_1,...,m_k)</span></span></code>.</p></li>
</ul>
</div></blockquote>
<p>This allows effectively modeling any computation, as one
can have function symbols modeling any sort of computations, from
equality testing to conditional branching or encryption functions.</p>
<p>In <strong>Squirrel</strong>, a function symbol without any assumption can be defined with:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">abstract</span><span> ok : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> ko : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> f1 : </span><span class="ansi-fg-light-cyan">message</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> f2 : </span><span class="ansi-fg-light-cyan">message</span><span> * </span><span class="ansi-fg-light-cyan">message</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>When using such function symbols inside a protocol, we are effectively
saying that those function symbol may be in practice instantiated by
any function of the correct type. And a proof in such a model holds
for any possible implementation of those functions. This is notably
useful to model a constant <cite>ok</cite>, without giving any specific concrete
value to this constant.</p>
<p><cite>ok</cite> and <cite>ko</cite> are constants, and <cite>f1</cite> is a function that expects a message, and
then return a message. <cite>f2</cite> is then a function symbol of arity two, and function
symbols of any arity can be defined this way.</p>
<p>A name <cite>n</cite> typically allows modeling secret keys or nounces. As we wish to
be able to refer to an unbounded number of sessions, we allow names to be
indexed, each value of the index yielding a fresh independent random value. We denote
by <cite>n[i]</cite> an indexed name, with variable <cite>i</cite> as an index. Names can be indexed
by any number of indices.</p>
<p>In the tool, one can declare names and indexed names with the following.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> n : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">name</span><span> n1 : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">name</span><span> n2 : </span><span class="ansi-fg-light-cyan">index</span><span> * </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n : [</span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n1 :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n1</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n2 :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
<p>Compared to usual game based cryptography, one can think about names as
sampling at the beginning of the protocol execution all possible random
values that will ever be needed, and store them within indexed cells, which
are our names.</p>
<p>To model a setting where multiple people each have their own secret key,
one could declare an indexed name as follows.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> key : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_key :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
</section>
<section id="basic-assumption">
<h2>Basic assumption<a class="headerlink" href="#basic-assumption" title="Permalink to this heading">Â¶</a></h2>
<p>We can declare axioms over our abstract function symbols, for instance
to state that the two abstract constant <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ok</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> are not
equal.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">axiom</span><span> [</span><span class="ansi-fg-light-blue">any</span><span>] ok_not_ko: ok &lt;&gt; ko.
</span></dt><dd class="squirreltop-hidden"><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] ok_not_ko : </span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span></dd>
</dl>
</div>
<p>A proof over such model would then apply to any concrete
implementation in which <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ok</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> are given two concrete
values as long as those two values are distinct.</p>
<p>Axioms are formulas in a high-order logic, for instance allowing free
variables, universal and existential quantification, implications,
etc. Here, we define the axiom as true over <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">any</span></span></code> protocol.</p>
<p>Another axiom that could be useful to prove the security of a protocol
is for instance that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> can never be equal to any pair
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;x,y&gt;</span></span></code>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">axiom</span><span> [</span><span class="ansi-fg-light-blue">any</span><span>] ok_not_pair (x,y:</span><span class="ansi-fg-light-cyan">message</span><span>): &lt;x,y&gt; &lt;&gt; fail.
</span></dt><dd class="squirreltop-hidden"><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] ok_not_pair : forall (x,y:message), &lt;x,y&gt; </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fail</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span></dd>
</dl>
</div>
<p>Going back to the name declaration, if we now display the <strong>Squirrel</strong>
output after a declaration, we see the following:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> skey : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_skey :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">skey</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
<p>This means that whenever a new name is declared, we also create a
dedicated axiom stating that the length of the name (which is a random
bitstring) is equal to some constant, which means that all names have
the same length.</p>
</section>
<section id="cryptographic-assumptions">
<h2>Cryptographic assumptions<a class="headerlink" href="#cryptographic-assumptions" title="Permalink to this heading">Â¶</a></h2>
<p>Symbol functions can be defined as being an encryption, or a hash function, or a
signature, orâ€¦ The tool will then assume that such functions satisfy some
classical cryptographic assumptions.</p>
<p>Some possible primitives and corresponding assumptions are:</p>
<blockquote>
<div><ul class="simple">
<li><p>encryption,  <strong>CCA1</strong> &amp; <strong>INT-CTXT</strong>, symmetric and asymmetric</p></li>
<li><p>signatures, <strong>EUF-CMA</strong></p></li>
<li><p>hash functions, <strong>PRF</strong>, and thus <strong>EUF-CMA</strong>, <strong>CR</strong></p></li>
</ul>
</div></blockquote>
<p>Each are declared in the following way.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">signature</span><span> sign,checksign,pk
</span><span class="ansi-fg-light-blue">hash</span><span> h
</span><span class="ansi-fg-light-blue">senc</span><span> enc,dec
</span><span class="ansi-fg-light-blue">aenc</span><span> asenc,asdec,aspk.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
</section>
<section id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this heading">Â¶</a></h2>
<p>Protocols are described inside a pi-calculus as <a class="reference internal" href="declarations.html#section-processes"><span class="std std-ref">processes</span></a>. It is based on the following constructs:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">new</span></span><span> <span class="pre">n</span></span></code> id used to declare a fresh name; (this is optional, and equivalent to declaring the names as seen before)</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">out</span></span><span><span class="pre">(c,m)</span></span></code> is used to send the term <cite>m</cite> over the channel <cite>c</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span><span class="pre">(c,x)</span></span></code> is used to receive some value from channel <cite>c</cite>, bound to the variable <cite>x</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">act;</span> <span class="pre">P</span></span></code> correspond to the sequential composition of action <cite>act</cite> with process <cite>P</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">process</span></span><span> </span><span class="ansi-fg-light-blue"><span class="pre">name</span></span><span><span class="pre">(vars)</span> <span class="pre">=</span> <span class="pre">...</span></span></code> allows declaring a process with a name, in which case using <cite>name(vars)</cite> inside another process unfold the process definition;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">P</span> <span class="pre">|</span> <span class="pre">Q</span></span></code> is a parallel composition of two processes;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">if</span></span><span> <span class="pre">phi</span> </span><span class="ansi-fg-light-blue"><span class="pre">then</span></span><span> <span class="pre">P</span> </span><span class="ansi-fg-light-blue"><span class="pre">else</span></span><span> <span class="pre">Q</span></span></code> is a conditional branching;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">try</span> <span class="pre">find</span></span><span> <span class="pre">vars</span> </span><span class="ansi-fg-light-blue"><span class="pre">such</span> <span class="pre">that</span></span><span> <span class="pre">phi</span> </span><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span> <span class="pre">P</span> </span><span class="ansi-fg-light-blue"><span class="pre">else</span></span><span> <span class="pre">Q</span></span></code> is a global lookup over indices, it can be seen as a lookup inside a database.</p></li>
</ul>
</div></blockquote>
<p>As an example, we use a small <em>RFID</em> based protocol, with a tag and a reader,
called the basic hash protocol <span id="id1">[<a class="reference internal" href="bibliography.html#id12" title="Mayla Bruso, Konstantinos Chatzikokolakis, and Jerry Den Hartog. Formal verification of privacy for rfid systems. In 2010 23rd IEEE Computer Security Foundations Symposium, 75â€“88. IEEE, 2010.">BCDH10</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic Hash</p>
<p>T â€“&gt; R : &lt;nT, h(nT,kT)&gt;</p>
<p>R â€“&gt; T : ok</p>
</div>
<p>Here, a tag <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T</span></span></code> sends to the reader <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code> a fresh challenge
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT</span></span></code>, authenticated via a MAC over the challenge using the key tag
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">kT</span></span></code>. Each tag has a distinct <code class="squirrelinline docutils literal notranslate"><span><span class="pre">kT</span></span></code>, and the reader has a
database containing all of them.</p>
<p>We first declare the channels used by the protocol. Remark that channels are
mostly byproducts of the theory, and do not play a big role.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">channel</span><span> cT
</span><span class="ansi-fg-light-blue">channel</span><span> cR.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>We then define the first process for the tags, which may correspond to
multiple identies, and thus depend on some index variable <cite>i</cite>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">process</span><span> tag(i:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">new</span><span> nT;
  T : </span><span class="ansi-fg-light-blue">out</span><span>(cT, &lt;nT, h(nT,key(i))&gt;).
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>We can then declare the reader.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">process</span><span> reader =
  </span><span class="ansi-fg-light-blue">in</span><span>(cT,x);
  </span><span class="ansi-fg-light-blue">try find</span><span> i </span><span class="ansi-fg-light-blue">such that</span><span> snd(x) = h(fst(x),key(i)) </span><span class="ansi-fg-light-blue">in</span><span>
    R : </span><span class="ansi-fg-light-blue">out</span><span>(cR,ok)
  </span><span class="ansi-fg-light-blue">else</span><span>
   R1 : </span><span class="ansi-fg-light-blue">out</span><span>(cR,ko).
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>And we finally declare the final system. We instantiate multiple copies
of the reader, and for each value <cite>i</cite>, we also instantiate multiple copies of
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">tag(i)</span></span></code> with the replication over <cite>k</cite>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">system</span><span> ((!_j reader) | (!_i !_k tag(i))).
</span></dt><dd><span>System before processing:
  
  (!_j </span><span class="ansi-bold ansi-fg-blue">reader</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> ) | (!_i !_k </span><span class="ansi-bold ansi-fg-blue">tag</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span>
</span><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_nT :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
Added action dependencies lemmas:

</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] mutex_default_R1_R :
  forall (j,i:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] mutex_default_R_R1 :
  forall (j,i:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] depends_default_init_T :
  forall (t:timestamp,i,k:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] depends_default_init_R1 :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] depends_default_init_R :
  forall (t:timestamp,j,i:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">

System after processing:
  
  (!_j
     </span><span class="ansi-bold">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold ansi-fg-magenta">x</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">);
     </span><span class="ansi-underline ansi-fg-red">find</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i) </span><span class="ansi-underline ansi-fg-red">such that</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (= (snd x) (h ((fst x), (key i)))) </span><span class="ansi-underline ansi-fg-red">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
       R: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ok); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-underline ansi-fg-red">else</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> R1: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ko); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) |
  (!_i !_k T: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,(pair (nT i k) (h ((nT i k), (key i))))); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span>
</span><span>System default registered with actions (init,R,R1,T).
</span></dd>
</dl>
</div>
<p>We see that when declaring such a system, in the final system after
processing, all outputs have been given name, each output then
corresponds to a possible action that can be triggered by the
attacker. Here, the possible actions are <code class="squirrelinline docutils literal notranslate"><span><span class="pre">(init,R,R1,T)</span></span></code>, and
many axioms are created, corresponding to the fact that for instance
actions <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R1</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code> are mutually exclusive as both
correspond to exclusive branches; this is the
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">mutex_default_R1_R</span></span></code> axiom, stating that for any possible
execution, one of the two actions must not happen in the trace.</p>
<p>A system declared this way is given the name <cite>default</cite>. Other systems can
be defined and given an explicit name. For instance, the following declare the
system <cite>simple</cite>, where each tag can only be executed once for each identity.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">system</span><span> [simple] ((!_j reader) | (!_i tag(i))).
</span></dt><dd class="squirreltop-hidden"><span>System before processing:
  
  (!_j </span><span class="ansi-bold ansi-fg-blue">reader</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> ) | (!_i </span><span class="ansi-bold ansi-fg-blue">tag</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span>
</span><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_nT1 :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT1</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
Added action dependencies lemmas:

</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:simple/left, right:simple/right] mutex_simple_R1_R :
  forall (j,i:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:simple/left, right:simple/right] mutex_simple_R_R1 :
  forall (j,i:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:simple/left, right:simple/right] depends_simple_init_T1 :
  forall (t:timestamp,i:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T1(i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T1(i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:simple/left, right:simple/right] depends_simple_init_R1 :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:simple/left, right:simple/right] depends_simple_init_R :
  forall (t:timestamp,j,i:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">

System after processing:
  
  (!_j
     </span><span class="ansi-bold">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold ansi-fg-magenta">x</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">);
     </span><span class="ansi-underline ansi-fg-red">find</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i) </span><span class="ansi-underline ansi-fg-red">such that</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (= (snd x) (h ((fst x), (key i)))) </span><span class="ansi-underline ansi-fg-red">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
       R: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ok); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-underline ansi-fg-red">else</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> R1: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ko); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) |
  (!_i T1: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,(pair (nT1 i) (h ((nT1 i), (key i))))); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span>
</span><span>System default registered with actions (init,R,R1,T).
</span><span>System simple registered with actions (init,R,R1,T1).
</span></dd>
</dl>
</div>
</section>
</section>
<section id="reachability-properties">
<h1>Reachability properties<a class="headerlink" href="#reachability-properties" title="Permalink to this heading">Â¶</a></h1>
<p>We express reachabilities formulas, that is, properties that talk
about what is possible or not for all traces, inside a first-order
logic. In <strong>Squirrel</strong>, such formulas are formally called
<a class="reference internal" href="logic.html#term-local-formula"><span class="xref std std-term">local formulas</span></a>.</p>
<p>In this logic, terms can be of type <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">message</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">boolean</span></span></code>,
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">index</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span></code>.  The logic proves that formulas are
true for all possible traces of the protocol, and for all possible
values of the variable given this trace.</p>
<p>For instance, a timestamp variable <cite>t</cite> allows talking about a given
point inside a trace. <cite>t</cite> will intuitively have to take the value of
some concrete action, e.g., <cite>T(i)</cite> or <cite>R(j)</cite> in our example.</p>
<section id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this heading">Â¶</a></h2>
<p>To discuss about the value of the output performed at some timestamp, we use macros:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;t</span></span></code> is the value given as input by the attacker to the action at t;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;t</span></span></code> is the output performed by action at t;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">cond</span></span><span><span class="pre">&#64;t</span></span></code> is the executability condition at t;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> is the sequence of all previous outputs up to t;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;t</span></span></code> is the conjunction of all executability conditions up to t.</p></li>
</ul>
</div></blockquote>
</section>
<section id="formulas">
<h2>Formulas<a class="headerlink" href="#formulas" title="Permalink to this heading">Â¶</a></h2>
<p>It is then possible to write formulas that capture properties
satisfied by all executions of the protocol. For instance, the
following formula describes that the executability execution of the
reader in fact implies some authentication property, in the sense that
there must exist an action <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code> that was executed before the
reader, and such the input of the reader corresponds to the name of
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">lemma</span><span> wa :
  </span><span class="ansi-fg-light-blue">forall</span><span> (i:</span><span class="ansi-fg-light-cyan">index</span><span>, j:</span><span class="ansi-fg-light-cyan">index</span><span>),
  </span><span class="ansi-fg-light-green">happens</span><span>(R(j,i)) =&gt;
     </span><span class="ansi-fg-light-green">cond</span><span>&#64;R(j,i) =&gt;
         </span><span class="ansi-fg-light-blue">exists</span><span> (k:</span><span class="ansi-fg-light-cyan">index</span><span>),
              T(i,k) &lt;= R(j,i) &amp;&amp; fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;R(j,i)) = nT(i,k).
</span></dt><dd><span>Goal wa :
  forall (i,j:index),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
</span></dd>
</dl>
</div>
<p>We write bellow the simple proof of this statement.  The high-level
idea of the proof is to use the EUF cryptographic axiom:
only the tag <cite>T(i,k)</cite> can compute <cite>h(nT(i,k),key(i))</cite> because the
secret key is not known by the attacker.  Therefore, any message
accepted by the reader must come from a tag that has played before.
The converse implication is trivial because any honest tag output is
accepted by the reader.</p>
<p>Once inside a proof context, delimited by <cite>Proof.</cite> and <cite>Qed.</cite>, it is
possible to get the list of available tactics by typing <cite>help.</cite>, and
details about any tactic with <cite>help tacticname.</cite></p>
<p>We now start the proof.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:default/left, right:default/right
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
forall (i,j:index),
  </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)

</span><span>
</span></dd>
</dl>
</div>
<p>After the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">Proof</span></span></code> command, <strong>Squirrel</strong> displays the current
judgement. It contains the number of goal that remains to be proved
(here, one, but subogals may be created by tactics), the system we are
working in, and the formula to be proved.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">intro</span><span> i j Hh Hc.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:default/left, right:default/right
Variables: i,j:index[const]
Hc: </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
Hh: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) 
</span><span>
</span></dd>
</dl>
</div>
<p>We have performed an introduction with the <a class="reference internal" href="proofs.html#squirrel:tacn.intro" title="intro"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> tactic. This
pushes universal quantifications inside the judgment context, where
the universal quantified variable become free variable. This allows us
to then push the left-hand side of the implications as hypothesis of
the judgment, that we can then reason on. The free variables and
assumptions are named according to the names passed as argument.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">cond</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:default/left, right:default/right
Variables: i,j:index[const]
Hc: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
Hh: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) 
</span><span>
</span></dd>
</dl>
</div>
<p>After introducing the hypothesis and expanding the executability
condition of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code>, we get an equality between a hash and some other
term <code class="squirrelinline docutils literal notranslate"><span><span class="pre">snd</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code>. We then use the unforgeability of the
hash function, the EUF assumption, to get that the hashed value
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">fst</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code> must be equal to some honestly hashed value
in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">snd</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code>, as the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">key</span></span></code> is secret. All
honestly hash are produced by the tag, which will then conclude our
proof. This cryptographic axiom is applied thanks to the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a>
tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Hc.
</span></dt><dd><span>Indirect bad occurrences of key key(i), and messages authenticated by it 
in other actions:
  </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) auth. by key(i) 
    (collision with </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) auth. by key(i))
    in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    in term &lt;</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;

Total: 1 occurrence
       0 of them are subsumed by another
       1 occurrence remaining
       
[goal&gt; Focused goal (1/1):
System: left:default/left, right:default/right
Variables: i,j:index[const]
Hc: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
Hh: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) 
</span><span>
</span></dd>
</dl>
</div>
<p>To conclude, we just have to use the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> introduced by the
<a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a> tactic as a witness for the existential <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> we have to
find.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">intro</span><span> [k _].
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:default/left, right:default/right
Variables: i,j,k:index[const]
Hc: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
Hh: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
_: </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) 
</span><span>
</span></dd>
<dt><span>  </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> k.
</span></dt><dd><span>[goal&gt; lemma wa is proved
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span class="ansi-fg-red">lemma</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:default/left, right:default/right] wa :
  forall (i,j:index),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j, i)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
Exiting proof mode.
</span><span>
</span></dd>
</dl>
</div>
</section>
</section>
<section id="equivalence-properties">
<h1>Equivalence properties<a class="headerlink" href="#equivalence-properties" title="Permalink to this heading">Â¶</a></h1>
<p>More complex properties based on equivalence can be
expressed. Intuitively, two processes are equivalent if the attacker
cannot know whether it is interacting with one or another. This is a
generic security property used in the computational model to prove
many distinct flavours of security.</p>
<p>We can declare in <strong>Squirrel</strong> two variants of a protocol at once using
the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(t1,t2)</span></span></code> operator. A process containing diff-terms is
called a bi-process, as it can lead to two distinct processes when
projecting on the left or the right of the diff. This allows to easily
model some security properties.</p>
<p>For instance, we can declare a bi-process <code class="squirrelinline docutils literal notranslate"><span><span class="pre">tagD</span></span></code> that models the
fact the on one side each tag may be called many times and always use
there own key, this is the real world, while on the right side, we in
fact use a new fresh independent key every time a tag is called. If
those two world are equivalent, then tags cannot be tracked.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> keyâ€™: </span><span class="ansi-fg-light-cyan">index</span><span> * </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>

</span><span class="ansi-fg-light-blue">process</span><span> tagD(i:</span><span class="ansi-fg-light-cyan">index</span><span>,k:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">new</span><span> nT;
  </span><span class="ansi-fg-light-blue">out</span><span>(cT, &lt;nT, h(nT,</span><span class="ansi-fg-light-green">diff</span><span>(key(i),keyâ€™(i,k)))&gt;).
</span></dt><dd><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_keyâ€™ :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
<dt><span class="ansi-fg-light-blue">process</span><span> readerD(j:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">in</span><span>(cT,x);
  </span><span class="ansi-fg-light-blue">if</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>), snd(x) = h(fst(x),</span><span class="ansi-fg-light-green">diff</span><span>(key(i),keyâ€™(i,k))) </span><span class="ansi-fg-light-blue">then</span><span>
    </span><span class="ansi-fg-light-blue">out</span><span>(cR,ok)
  </span><span class="ansi-fg-light-blue">else</span><span>
    </span><span class="ansi-fg-light-blue">out</span><span>(cR,ko)

</span><span class="ansi-fg-light-blue">system</span><span> [BasicHash] ((!_j R: readerD(j)) | (!_i !_k T: tagD(i,k))).
</span></dt><dd><span>System before processing:
  
  (!_j R: </span><span class="ansi-bold ansi-fg-blue">readerD</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> j) | (!_i !_k T: </span><span class="ansi-bold ansi-fg-blue">tagD</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i k)
</span><span>
</span><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_nT2 :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
Added action dependencies lemmas:

</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] mutex_BasicHash_R1_R2 :
  forall (j:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] mutex_BasicHash_R2_R1 :
  forall (j:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] depends_BasicHash_init_T :
  forall (t:timestamp,i,k:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] depends_BasicHash_init_R1 :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] depends_BasicHash_init_R2 :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">

System after processing:
  
  (!_j
     </span><span class="ansi-bold">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold ansi-fg-magenta">x</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">);
     </span><span class="ansi-underline ansi-fg-red">if</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [mexists</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i : index, k : index), (= (snd x)
        (h ((fst x), [mdiff</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">((key i),(keyâ€™ (i, k)))))) </span><span class="ansi-underline ansi-fg-red">then</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> R2: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ok); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-underline ansi-fg-red">else</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> R1: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,ko); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) |
  (!_i
     !_k
       T:
       </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,(pair (nT2 i k) (h ((nT2 i k), [mdiff</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">((key i),(keyâ€™ (i, k)))))));
       </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span>
</span><span>System BasicHash registered with actions (init,R2,R1,T).
</span><span>System default registered with actions (init,R,R1,T).
</span><span>System simple registered with actions (init,R,R1,T1).
</span></dd>
</dl>
</div>
<p>Importantly, reachability formulas can be expressed and proved
directly on bi-systems. We can for instance do a variant of the
previous proof on the bi-system directly:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">lemma</span><span> [BasicHash] wa_R :
  </span><span class="ansi-fg-light-blue">forall</span><span> (tau:</span><span class="ansi-fg-light-cyan">timestamp</span><span>),
    </span><span class="ansi-fg-light-green">happens</span><span>(tau) =&gt;
    ((</span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>),
       snd(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau) = h(fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau),</span><span class="ansi-fg-light-green">diff</span><span>(key(i),keyâ€™(i,k))))
     &lt;=&gt;
     (</span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>), T(i,k) &lt; tau &amp;&amp;
       fst(</span><span class="ansi-fg-light-green">output</span><span>&#64;T(i,k)) = fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau) &amp;&amp;
       snd(</span><span class="ansi-fg-light-green">output</span><span>&#64;T(i,k)) = snd(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau))).
</span></dt><dd><span>Goal wa_R :
  forall (tau:timestamp),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    (exists (i,k:index),
       </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (i,k:index),
      </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
</span></dd>
</dl>
</div>
<p>The idea of the proof is similar, except that we prove here an
equivalence instead of an implication.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:BasicHash/left, right:BasicHash/right
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
forall (tau:timestamp),
  </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  (exists (i,k:index),
     </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  exists (i,k:index),
    </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span>  </span><span class="ansi-fg-light-blue">intro</span><span> tau Hap.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:BasicHash/left, right:BasicHash/right
Variables: tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(exists (i,k:index),
   </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>We have to prove two implications (<cite>&lt;=&gt;</cite>): we thus split the proof
in two parts. We now have two different goals to prove.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> [i k Meq].
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
System: left:BasicHash/left, right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>For the first implication (=&gt;), we actually prove it separately for
the real system (left) and the ideal system (right).</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">project</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>The proof is very similar on both sides and relies on the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a>
tactic.  Applying the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a> tactic on the <cite>Meq</cite> hypothesis
generates a new hypothesis stating that <cite>fst(input&#64;R(j))</cite> must be
equal to some message that has already been hashed before.  The only
possibility is that this hash comes from the output of a tag that has
played before (thus the new hypothesis on timestamps).</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Meq.
</span></dt><dd><span>Indirect bad occurrences of key key(i), and messages authenticated by it 
in other actions:
  </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) auth. by key(i) 
    (collision with </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) auth. by key(i))
    in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;

Total: 1 occurrence
       0 of them are subsumed by another
       1 occurrence remaining
       
[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">intro</span><span> [k0 _].
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k,k0:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
_: </span><span class="ansi-fg-green">T(i, k0)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k0)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k0.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
System: right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>The right side of the proof is very similar.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Meq =&gt; *.
</span></dt><dd><span>Indirect bad occurrences of key keyâ€™((i, k)),
         and messages authenticated by it 
in other actions:
  </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) auth. by keyâ€™((i, k)) 
    (collision with </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) auth. by keyâ€™((i, k)))
    in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;

Total: 1 occurrence
       0 of them are subsumed by another
       1 occurrence remaining
       
[goal&gt; Focused goal (1/2):
System: right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
H: </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: left:BasicHash/left, right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))

</span><span>
</span></dd>
</dl>
</div>
<p>We use here the notation <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span><span> <span class="pre">Meq</span> <span class="pre">=&gt;</span> <span class="pre">*</span></span></code>, which is a shortcut for
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span><span> <span class="pre">Meq;</span> </span><span class="ansi-fg-light-blue"><span class="pre">intro</span></span><span> <span class="pre">*</span></span></code>, the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">*</span></span></code> doing introduction with automatic
naming of variables and hypothesis.</p>
<p>For the second implication (&lt;=), the conclusion of the goal can
directly be obtained from the hypotheses.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k.
</span></dt><dd><span>[goal&gt; lemma wa_R is proved
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span class="ansi-fg-red">lemma</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right] wa_R :
  forall (tau:timestamp),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    (exists (i,k:index),
       </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (i,k:index),
      </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
Exiting proof mode.
</span><span>
</span></dd>
</dl>
</div>
<p>We now prove an equivalence property expressing unlinkability of the
protocol. This property is expressed by the logical formula <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">forall</span></span><span>
<span class="pre">t:</span></span><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span><span><span class="pre">,</span> <span class="pre">[</span></span><span class="ansi-fg-light-green"><span class="pre">happens</span></span><span><span class="pre">(t)]</span> <span class="pre">-&gt;</span> </span><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span><span><span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t)</span></span></code> where <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> is
actually a bi-frame. This state that for any trace (the quantification
is implicit over all traces), for any point that happens in the trace,
the two frames (based on the diff operator) are equivalent. Square
brackets contain local formulas, and such a formula mixing both local
formulas and equivalences is called a <a class="reference internal" href="logic.html#term-global-formula"><span class="xref std std-term">global formula</span></a>.</p>
<p>Here, we will have to prove that the left projection of <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> (<em>i.e.</em>
the real system) is indistinguishable from the right projection of
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> (<em>i.e</em> the ideal system).</p>
<p>As this goal is a frequent one, a shortcut allows declaring this goal
without writing the full formula.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">equiv</span><span> [BasicHash] unlinkability.
</span></dt><dd><span>Goal unlinkability :
  forall t:timestamp[const, glob], equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;t)
</span></dd>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: t:timestamp[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t)]
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;t
 
</span><span>
</span></dd>
</dl>
</div>
<p>An equivalence judgment contains the list of hypothesis, as
before. The conclusion is however different to the reachability
case. Now, we have a numbered list of diff-terms, we must prove that
for each of them, the left projection and the right projection are
indistinguishable. We refer to this sequence of diff terms as the
biframe of the goal.</p>
<p>The high-level idea of the proof is as follows:</p>
<ul class="simple">
<li><p>if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> corresponds to a readerâ€™s action, we show that the outcome of the
conditional is the same on both sides and that this outcome only depends
on information already available to the attacker;</p></li>
<li><p>if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> corresponds to a tagâ€™s action, we show that the new message added
in the frame (_i.e._ the tagâ€™s output) does not give any information to
the attacker to distinguish the real system from the ideal one since
hashes can intuitively be seen as fresh names thanks to the PRF
cryptographic axiom.</p></li>
</ul>
<p>The proof is done by induction over the timestamp <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.  The
<cite>induction</cite> tactic also automatically introduces a case analysis over
all the possible values for <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.  The first case, where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span>
<span class="pre">init</span></span></code> corresponds to first point of the execution trace where no
protocol action happened, is trivial, we directly close it with
<a class="reference internal" href="proofs.html#squirrel:tacn.auto" title="auto"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>.  The other cases correspond to the 3 different actions
of the protocol.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">induction</span><span> t.
</span></dt><dd><span>[goal&gt; Focused goal (1/4):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">auto</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>For the case where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">R2(j)</span></span></code>, we start by expanding the macros
and splitting the pairs. Splitting the pairs is done by using the
<a class="reference internal" href="proofs.html#squirrel:tacn.fa" title="fa"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fa</span></code></a> tactic, which when applied to all pairs thanks to the
pattern <code class="squirrelinline docutils literal notranslate"><span><span class="pre">!&lt;_,_&gt;</span></span></code> splits a bi-frame element containing a pair into
two biframe elements for each element of the pair.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: &lt;</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
    &lt;</span><span class="ansi-bold">of_bool</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
     if (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) then </span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&gt;&gt;
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>Using the authentication goal <code class="squirrelinline docutils literal notranslate"><span><span class="pre">wa_R</span></span></code> previously proved, we replace
the formula <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">cond</span></span><span><span class="pre">&#64;R2(j)</span></span></code> by an equivalent formula expressing the
fact that a tag <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code> has played before and that the output of
this tag is the message inputted by the reader. This is one of the
strength of <strong>Squirrel</strong>, we can finely reuse previously proved goals to
simplify a current goal. Here, as we can see the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">wa_R</span></span></code> tactic as a
rewriting rule over boolean formulas, we use the <a class="reference internal" href="proofs.html#squirrel:tacn.rewrite" title="rewrite"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>
tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">rewrite</span><span> /</span><span class="ansi-fg-light-green">cond</span><span> (wa_R (R2 j)) //.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
   exists (i,k:index),
     </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
 
</span><span>
</span></dd>
</dl>
</div>
<p>We are now able to remove this formula from the frame because the
attacker is able to compute it using information obtained in the
past. Indeed, each element of this formula is already available in
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;pred(R2(j))</span></span></code>. This is done by the <a class="reference internal" href="proofs.html#squirrel:tace.deduce" title="deduce"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">deduce</span></code></a> tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">deduce</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>In the case where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">R1(j)</span></span></code>, it is similar to the previous one.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: &lt;</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
    &lt;</span><span class="ansi-bold">of_bool</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
     if (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) then </span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&gt;&gt;
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">rewrite</span><span> /</span><span class="ansi-fg-light-green">cond</span><span> (wa_R (R1 j)) //.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
   </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> exists (i,k:index),
         </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
         </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
         </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">deduce</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>Finally, for the case where t = T(i,k), we start by expanding the
macros and splitting the pairs.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">cond</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: &lt;</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
    &lt;</span><span class="ansi-bold">of_bool</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">true</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
     if (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">true</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) then
       &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))&gt;&gt;&gt;
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;, </span><span class="ansi-fg-light-blue">if</span><span> _ </span><span class="ansi-fg-light-blue">then</span><span> _, &lt;_,_&gt;.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
2: </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))
 
</span><span>
</span></dd>
</dl>
</div>
<p>We now apply the <a class="reference internal" href="proofs.html#squirrel:tace.prf" title="prf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">prf</span></code></a> tactic, in order to replace the hash by a fresh
name, and creates a subgoal asking to prove that the hashed value is indeed fresh.
The goal is now to prove that this condition always evaluates to <cite>true</cite>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">prf</span><span> </span><span class="ansi-fg-light-blue">2</span><span>.
</span></dt><dd><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n_PRF : [</span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n_PRF</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
Applying PRF to </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))

Checking for occurrences on the left
 Indirect bad occurrences of key key(i), and messages hashed by it 
 in other actions:
   </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) hashed by key(i) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by key(i))
     in action </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
   
   </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) hashed by key(i) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by key(i))
     in action </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
   
   </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by key(i) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by key(i))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
 
 Total: 3 occurrences
        0 of them are subsumed by another
        3 occurrences remaining
        
 
Checking for occurrences on the right
 Indirect bad occurrences of key keyâ€™((i, k)), and messages hashed by it 
 in other actions:
   </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) hashed by keyâ€™((i, k)) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by keyâ€™((i, k)))
     in action </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
   
   </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) hashed by keyâ€™((i, k)) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by keyâ€™((i, k)))
     in action </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
   
   </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by keyâ€™((i, k)) 
     (collision with </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) hashed by keyâ€™((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
 
 Total: 3 occurrences
        0 of them are subsumed by another
        3 occurrences remaining
        
 
[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
        (equivalences: left:BasicHash/left, right:BasicHash/right)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(forall (i0,j:index),
   </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(forall (i0,j:index),
   </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
forall (i0,k0:index),
  </span><span class="ansi-fg-green">T(i0, k0)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i0, k0)

</span><span>
</span></dd>
</dl>
</div>
<p>Several conjuncts must now be proved, the same tactic can be used on
all of them. Here are representative cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>In one case, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span></span></code> cannot occur in <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R2(j)</span></span></code>
because <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R2(j)</span> <span class="pre">&lt;</span> <span class="pre">T(i,k)</span></span></code>.</p></li>
<li><p>In another case, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span> <span class="pre">=</span> <span class="pre">nT(i0,k0)</span></span></code> implies that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i=i0</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k=k0</span></span></code>,
contradicting <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i0,k0)&lt;T(i,k)</span></span></code>.</p></li>
</ul>
</div></blockquote>
<p>In both cases, the reasoning is performed by the fresh tactic on the
message equality hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">Meq</span></span></code> whose negation must initially be
proved.  To be able to use (split and) fresh, we first project the
goal into one goal for the left projection and one goal for the
right projection of the initial bi-system.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">repeat</span><span> </span><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> *; </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> Meq.
</span></dt><dd><span>Freshness of occurrences of nT2((i, k)):
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
  Freshness of occurrences of nT2((i, k)):
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
  Freshness of occurrences of nT2((i, k)):
 Direct occurrences of nT2((i, k))  in </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k0):
   nT2((i, k0)) (collision with nT2((i, k))) in term </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k0)
 
 
 Total: 1 occurrence
        0 of them are subsumed by another
        1 occurrence remaining
        
 
[goal&gt; Focused goal (1/2):
System: right:BasicHash/right
        (equivalences: left:BasicHash/left, right:BasicHash/right)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(forall (k0,i0,j:index),
   </span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R2(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(forall (k0,i0,j:index),
   </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
forall (i0,k0:index),
  </span><span class="ansi-fg-green">T(i0, k0)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i0 </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> k0 </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i0, k0)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">repeat</span><span> </span><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> *; </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> Meq.
</span></dt><dd><span>Freshness of occurrences of nT2((i, k)):
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
  Freshness of occurrences of nT2((i, k)):
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
  Freshness of occurrences of nT2((i, k)):
 Direct occurrences of nT2((i, k))  in </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i0, k0):
   nT2((i0, k0)) (collision with nT2((i, k))) in term </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i0, k0)
 
 
 Total: 1 occurrence
        0 of them are subsumed by another
        1 occurrence remaining
        
 
[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
2: </span><span class="ansi-fg-yellow">n_PRF</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>We have now replaced the hash by a fresh name occurring nowhere else,
so we can remove it using the <a class="reference internal" href="proofs.html#squirrel:tacn.fresh" title="fresh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">fresh</span><span> </span><span class="ansi-fg-light-blue">2</span><span>; </span><span class="ansi-fg-light-blue">1</span><span>:</span><span class="ansi-fg-light-blue">auto</span><span>.
</span></dt><dd><span>Freshness on the left side:
 
 
Freshness on the right side:
 
 
[goal&gt; Focused goal (1/1):
Systems: left:BasicHash/left, right:BasicHash/right (same for equivalences)
Variables: i,k:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
 
</span><span>
</span></dd>
</dl>
</div>
<p>We can also remove the name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span></span></code>, and conclude by induction
hypothesis.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>Freshness on the left side:
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
 
Freshness on the right side:
 Indirect occurrences of nT2((i, k))  in other actions:
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
   
   nT2((i, k)) 
     (collision with nT2((i, k)))
     in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     in term &lt;</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">keyâ€™</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;
 
 Total: 2 occurrences
        1 of them is subsumed by another
        1 occurrence remaining
        
 
[goal&gt; lemma unlinkability is proved
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span>global </span><span class="ansi-fg-red">lemma</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [left:BasicHash/left, right:BasicHash/right
              (same for equivalences)] unlinkability :
  Forall (t:timestamp[const, glob]), [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t)] -&gt; equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;t)
Exiting proof mode.
</span><span>
</span></dd>
</dl>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="commands.html" class="btn btn-neutral float-left" title="Commands" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="appendix/indexes/index.html" class="btn btn-neutral float-right" title="Indexes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Squirrel developpers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>