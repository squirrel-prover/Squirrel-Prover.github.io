<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Protocol modelling &mdash; Squirrel  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/ansi.css" type="text/css" />
      <link rel="stylesheet" href="_static/notations.css" type="text/css" />
      <link rel="stylesheet" href="_static/pre-text.css" type="text/css" />
      <link rel="stylesheet" href="_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/rtd_sphinx_search.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/notations.js"></script>
        <script src="_static/js/rtd_search_config.js"></script>
        <script src="_static/js/rtd_sphinx_search.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Indexes" href="appendix/indexes/index.html" />
    <link rel="prev" title="Commands" href="commands.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Squirrel
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Introduction</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="reference-intro.html">Notations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="reference-intro.html#lexical-conventions">Lexical conventions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="reference-intro.html#infix-operators">Infix operators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="logic.html">Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="logic.html#types">Types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#base-types">Base types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#type-variables-and-polymorphism">Type variables and polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#general-types">General types</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#binders-and-tags">Binders and tags</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#terms-with-binders">Terms with binders</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#multi-terms">Multi-terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#diff-terms">Diff-terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#macros">Macros</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="logic.html#formulas">Formulas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="logic.html#local-formulas">Local formulas</a></li>
<li class="toctree-l3"><a class="reference internal" href="logic.html#global-formulas">Global formulas</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="declarations.html">Declarations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#names">Names</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#abstract-functions">Abstract functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#operators">Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#built-ins">Built-ins</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#cryptographic-functions">Cryptographic functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#processes">Processes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#channels">Channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#memory-cells">Memory cells</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#id4">Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="declarations.html#systems-and-actions">Systems and actions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-defined-macros">System-defined macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-expressions">System expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="declarations.html#system-contexts">System contexts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="declarations.html#axioms-and-lemmas">Axioms and Lemmas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="proofs.html">Proofs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#judgements">Judgements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#logical-variables">Logical variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#hypotheses">Hypotheses</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#local-judgement">Local judgement</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#global-judgement">Global judgement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#generalities">Generalities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#tactic-arguments">Tactic arguments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#intro-patterns">Intro patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#proof-terms">Proof terms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#proof-term-resolution">Proof-term resolution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#reduction">Reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#automatic-simplification-tactics">Automatic simplification tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#common-errors">Common errors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="proofs.html#id4">Tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#generic-tactics">Generic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#common-tactics">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#local-tactics">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#global-tactics">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#structural-tactics">Structural tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id9">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id11">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id12">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#cryptographic-tactics">Cryptographic tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#occurrence-formula">Occurrence formula</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id15">Common tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id18">Local tactics</a></li>
<li class="toctree-l4"><a class="reference internal" href="proofs.html#id28">Global tactics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="proofs.html#utility-tactics">Utility tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Protocol modelling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-assumption">Basic assumption</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cryptographic-assumptions">Cryptographic assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#protocols">Protocols</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#reachability-properties">Reachability properties</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#formulas">Formulas</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#equivalence-properties">Equivalence properties</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="appendix/indexes/index.html">Indexes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="std-glossindex.html">Glossary index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-declindex.html">Declaration index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-cmdindex.html">Command index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-tacindex.html">Tactic index</a></li>
<li class="toctree-l2"><a class="reference internal" href="squirrel-exnindex.html">Errors and warnings index</a></li>
<li class="toctree-l2"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="doc-writing.html">Documenting Squirrel with Sphinx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#todo-list-generation">TODO list generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-objects">Squirrel objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#notations">Notations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#objects">Objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-directives">Squirrel directives</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#squirrel-roles">Squirrel roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#common-mistakes">Common mistakes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#improper-nesting">Improper nesting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-token">Overusing <code class="docutils literal notranslate"><span class="pre">:token:</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#omitting-annotations">Omitting annotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#using-the-squirreltop-directive-for-syntax-highlighting">Using the <code class="docutils literal notranslate"><span class="pre">..</span> <span class="pre">squirreltop::</span></code> directive for syntax highlighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-plain-quotes">Overusing plain quotes</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#overusing-the-example-directive">Overusing the <code class="docutils literal notranslate"><span class="pre">example</span></code> directive</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="doc-writing.html#tips-and-tricks">Tips and tricks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#nested-lemmas">Nested lemmas</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#abbreviations-and-macros">Abbreviations and macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="doc-writing.html#advanced-uses-of-notations">Advanced uses of notations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Squirrel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Protocol modelling</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/squirrel-prover/squirrel-prover/blob/master/documentation/sphinx/source/tutorial.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="math-preamble math notranslate nohighlight">
\[\begin{split}\newcommand{\as}{\kw{as}}
\newcommand{\case}{\kw{case}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\In}{\kw{in}}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[4]{\kw{Ind}_{#4}[#1](#2:=#3)}
\newcommand{\Indpstr}[5]{\kw{Ind}_{#4}[#1](#2:=#3)/{#5}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModImp}[3]{{\kw{Mod}}({#1}:{#2}:={#3})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\plus}{\mathsf{plus}}
\newcommand{\SProp}{\textsf{SProp}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\Sort}{\mathcal{S}}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\trii}{\triangleright_\iota}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\mathcal{W\!F}}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\mathcal{W\!F}}(#2)}
\newcommand{\WFTWOLINES}[2]{{\mathcal{W\!F}}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\end{split}\]</div>
<span class="target" id="tutorial"></span><p>This tutorial provides a very quick introduction to the main concepts
of <strong>Squirrel</strong>. It can be used to ease its discovery and to get an
intuitive grasp of the multiple concepts by going through a concrete
example. The reference manual provides a more extensive presentation
of all the concepts.</p>
<p>In many cases, the concepts introduced here are also direct clickable
references to the more extensive presentation in the reference manual.</p>
<section id="protocol-modelling">
<h1>Protocol modelling<a class="headerlink" href="#protocol-modelling" title="Permalink to this heading">¶</a></h1>
<p>Squirrel allows performing proofs of security for communication
protocols relying on cryptography. It works within a high-order logic,
and a first step is to be able to model all the components of a
protocol inside the logic.</p>
<section id="messages">
<h2>Messages<a class="headerlink" href="#messages" title="Permalink to this heading">¶</a></h2>
<p>Messages computed by a protocol and sent over the
network are modelled using <a class="reference internal" href="logic.html#term-term"><span class="std std-ref">terms</span></a>.</p>
<p>Concretely, a term is built from</p>
<blockquote>
<div><ul class="simple">
<li><p>names <code class="squirrelinline docutils literal notranslate"><span><span class="pre">n</span></span></code> used to model random sampling;</p></li>
<li><p>application of functions <code class="squirrelinline docutils literal notranslate"><span><span class="pre">f(m_1,...,m_k)</span></span></code>.</p></li>
</ul>
</div></blockquote>
<p>This allows effectively modelling any computation, as one
can have function symbols modelling any sort of computations, from
equality testing to conditional branching or encryption functions.</p>
<p>In <strong>Squirrel</strong>, a function symbol without any assumption can be defined with:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">abstract</span><span> ok : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> ko : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> f1 : </span><span class="ansi-fg-light-cyan">message</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">abstract</span><span> f2 : </span><span class="ansi-fg-light-cyan">message</span><span> * </span><span class="ansi-fg-light-cyan">message</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>When using such function symbols inside a protocol, we are effectively
saying that those function symbol may be in practice instantiated by
any function of the correct type. And a proof in such a model holds
for any possible implementation of those functions. This is notably
useful to model a constant <cite>ok</cite>, without giving any specific concrete
value to this constant.</p>
<p><cite>ok</cite> and <cite>ko</cite> are constants, and <cite>f1</cite> is a function that expects a message, and
returns a message. <cite>f2</cite> is then a function symbol of arity two. Function
symbols of any arity can be defined similarly.</p>
<p>A name <cite>n</cite> typically allows to model secret keys or nonces. As we wish to
be able to refer to an unbounded number of sessions, we allow names to be
indexed, each value of the index yielding a fresh independent random value. An indexed
name is denoted by <cite>n[i]</cite>, with variable <cite>i</cite> as an index. Names can be indexed
by any number of indices.</p>
<p>In the tool, one can declare names and indexed names as follows.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> n : </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">name</span><span> n1 : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>
</span><span class="ansi-fg-light-blue">name</span><span> n2 : </span><span class="ansi-fg-light-cyan">index</span><span> * </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n : [</span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">n</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n1 :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n1</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_n2 :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">n2</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
<p>Compared to usual game based cryptography, one can think about names as
sampling at the beginning of the protocol execution all possible random
values that will ever be needed, and store them within indexed cells, which
are our names.</p>
<p>To model a setting where multiple people each have their own secret key,
one could declare an indexed name as follows.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> key : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd class="squirreltop-hidden"><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_key :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
</section>
<section id="basic-assumption">
<h2>Basic assumption<a class="headerlink" href="#basic-assumption" title="Permalink to this heading">¶</a></h2>
<p>We can declare axioms over our abstract function symbols, for instance
to state that the two abstract constant <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ok</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> are not
equal.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">axiom</span><span> [</span><span class="ansi-fg-light-blue">any</span><span>] ok_not_ko: ok &lt;&gt; ko.
</span></dt><dd class="squirreltop-hidden"><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] ok_not_ko : </span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span></dd>
</dl>
</div>
<p>A proof made in such a model would then apply to any concrete
implementation in which <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ok</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> are given two distinct
concrete values.</p>
<p>Axioms are formulas in a high-order logic, for instance allowing free
variables, universal and existential quantification, implications,
etc. Here, we define the axiom as true over <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">any</span></span></code> protocol.</p>
<p>Another axiom that could be useful to prove the security of a protocol
is for instance that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">ko</span></span></code> can never be equal to any pair
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;x,y&gt;</span></span></code>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">axiom</span><span> [</span><span class="ansi-fg-light-blue">any</span><span>] ok_not_pair (x,y:</span><span class="ansi-fg-light-cyan">message</span><span>): &lt;x,y&gt; &lt;&gt; ko.
</span></dt><dd class="squirreltop-hidden"><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] ok_not_pair : forall (x,y:message), &lt;x,y&gt; </span><span class="ansi-bold">&lt;&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span></dd>
</dl>
</div>
<p>Going back to the name declaration, if we now display the <strong>Squirrel</strong>
output after a declaration, we see the following:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> skey : </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>.
</span></dt><dd><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_skey :
  [forall (i:index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">skey</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]</span></dd>
</dl>
</div>
<p>This means that whenever a new name is declared, we also create a
dedicated axiom stating that the length of the name (which is a random
bitstring) is equal to some constant. In other words, all names have
the same length.</p>
</section>
<section id="cryptographic-assumptions">
<h2>Cryptographic assumptions<a class="headerlink" href="#cryptographic-assumptions" title="Permalink to this heading">¶</a></h2>
<p>Function symbols can be defined as being encryption functions, hash functions,
signature functions, etc. The tool will then assume that such functions satisfy some
classical cryptographic assumptions.</p>
<p>Some possible primitives, and the corresponding assumptions, are:</p>
<blockquote>
<div><ul class="simple">
<li><p>symmetric and asymmetric encryption,
<strong>CCA1</strong> &amp; <strong>INT-CTXT</strong> (only in the symmetric case)</p></li>
<li><p>signature, <strong>EUF-CMA</strong></p></li>
<li><p>hash function, <strong>PRF</strong>, and thus <strong>EUF-CMA</strong>, <strong>CR</strong></p></li>
</ul>
</div></blockquote>
<p>Each is declared in the following way.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">signature</span><span> sign,checksign,pk
</span><span class="ansi-fg-light-blue">hash</span><span> h
</span><span class="ansi-fg-light-blue">senc</span><span> enc,dec
</span><span class="ansi-fg-light-blue">aenc</span><span> asenc,asdec,aspk.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
</section>
<section id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this heading">¶</a></h2>
<p>Protocols are described in a variant of the pi-calculus as
<a class="reference internal" href="declarations.html#section-processes"><span class="std std-ref">processes</span></a>. They are defined by the following constructs:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">new</span></span><span> <span class="pre">n</span></span></code> is used to declare a fresh name (this is optional, and equivalent to the style of name declarations described earlier);</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">out</span></span><span><span class="pre">(c,m)</span></span></code> is used to send term <cite>m</cite> over channel <cite>c</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span><span class="pre">(c,x)</span></span></code> is used to receive some value from channel <cite>c</cite>, bound to the variable <cite>x</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">act;</span> <span class="pre">P</span></span></code> correspond to the sequential composition of action <cite>act</cite> with process <cite>P</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">process</span></span><span> </span><span class="ansi-fg-light-blue"><span class="pre">name</span></span><span><span class="pre">(vars)</span> <span class="pre">=</span> <span class="pre">...</span></span></code> allows to give a name to a process: using <cite>name(vars)</cite> inside another process then unfold the process definition;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span><span class="pre">P</span> <span class="pre">|</span> <span class="pre">Q</span></span></code> is the parallel composition of two processes;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">if</span></span><span> <span class="pre">phi</span> </span><span class="ansi-fg-light-blue"><span class="pre">then</span></span><span> <span class="pre">P</span> </span><span class="ansi-fg-light-blue"><span class="pre">else</span></span><span> <span class="pre">Q</span></span></code> is conditional branching;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">try</span> <span class="pre">find</span></span><span> <span class="pre">vars</span> </span><span class="ansi-fg-light-blue"><span class="pre">such</span> <span class="pre">that</span></span><span> <span class="pre">phi</span> </span><span class="ansi-fg-light-blue"><span class="pre">in</span></span><span> <span class="pre">P</span> </span><span class="ansi-fg-light-blue"><span class="pre">else</span></span><span> <span class="pre">Q</span></span></code> is a global lookup over indices, it can be seen as a lookup in a database.</p></li>
</ul>
</div></blockquote>
<p>As an example, we use a small <em>RFID</em>-based protocol, with a tag and a reader,
called the basic hash protocol <span id="id1">[<a class="reference internal" href="bibliography.html#id12" title="Mayla Bruso, Konstantinos Chatzikokolakis, and Jerry Den Hartog. Formal verification of privacy for rfid systems. In 2010 23rd IEEE Computer Security Foundations Symposium, 75–88. IEEE, 2010.">BCDH10</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Example: Basic Hash</p>
<p>T –&gt; R : &lt;nT, h(nT,kT)&gt;</p>
<p>R –&gt; T : ok</p>
</div>
<p>Here, a tag <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T</span></span></code> sends to the reader <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code> a fresh challenge
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT</span></span></code>, authenticated via a MAC using the tag’s key
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">kT</span></span></code>. Each tag has a distinct <code class="squirrelinline docutils literal notranslate"><span><span class="pre">kT</span></span></code>, and the reader has a
database containing all of them.</p>
<p>We first declare the channels used by the protocol. Remark that channels are
mostly byproducts of the theory, and do not play a big role.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl class="simple">
<dt><span class="ansi-fg-light-blue">channel</span><span> cT
</span><span class="ansi-fg-light-blue">channel</span><span> cR.
</span></dt><dd class="squirreltop-hidden"></dd>
</dl>
</div>
<p>We then define the first process for the tags, which may correspond to
multiple identities, and thus depends on some index variable <cite>i</cite>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">process</span><span> tag(i:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">new</span><span> nT;
  T : </span><span class="ansi-fg-light-blue">out</span><span>(cT, &lt;nT, h(nT,kT(i))&gt;).
</span></dt><dd class="squirreltop-hidden"><span>[error&gt; [error-57-59]
Error: unknown symbol kT
</span></dd>
</dl>
</div>
<p>We now declare the process for the reader.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">process</span><span> reader =
  </span><span class="ansi-fg-light-blue">in</span><span>(cT,x);
  </span><span class="ansi-fg-light-blue">try find</span><span> i </span><span class="ansi-fg-light-blue">such that</span><span> snd(x) = h(fst(x),kT(i)) </span><span class="ansi-fg-light-blue">in</span><span>
    R : </span><span class="ansi-fg-light-blue">out</span><span>(cR,ok)
  </span><span class="ansi-fg-light-blue">else</span><span>
   R1 : </span><span class="ansi-fg-light-blue">out</span><span>(cR,ko).
</span></dt><dd class="squirreltop-hidden"><span>[error&gt; [error-70-72]
Error: unknown symbol kT
</span></dd>
</dl>
</div>
<p>Finally, we declare the complete system. We instantiate multiple copies
of the reader process, and for each value <cite>i</cite>, we also instantiate multiple copies of
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">tag(i)</span></span></code> with the replication over <cite>k</cite>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">system</span><span> ((!_j reader) | (!_i !_k tag(i))).
</span></dt><dd><span>[error&gt; [error-32-35]
Error: unknown symbol tag
</span></dd>
</dl>
</div>
<p>We see that with this declaration, in the resulting system after
processing, all outputs have been given a name, and each output
corresponds to a possible action that can be triggered by the
attacker. Here, the possible actions are <code class="squirrelinline docutils literal notranslate"><span><span class="pre">(init,R,R1,T)</span></span></code>.
Many axioms are created, expressing the fact that for instance
actions <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R1</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code> are mutually exclusive, as they
are exclusive branches; this is the
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">mutex_default_R1_R</span></span></code> axiom, stating that for any possible
execution, the two actions cannot both happen in the trace.</p>
<p>A system declared this way is given the name <cite>default</cite>. Other systems can
be defined and given an explicit name. For instance, the following declares the
system <cite>simple</cite>, where each tag can only be executed once for each identity.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">system</span><span> [simple] ((!_j reader) | (!_i tag(i))).
</span></dt><dd class="squirreltop-hidden"><span>[error&gt; [error-37-40]
Error: unknown symbol tag
</span></dd>
</dl>
</div>
</section>
</section>
<section id="reachability-properties">
<h1>Reachability properties<a class="headerlink" href="#reachability-properties" title="Permalink to this heading">¶</a></h1>
<p>We consider reachability formulas, that is, properties that talk
about what is possible or not for all traces.
In <strong>Squirrel</strong>, we express such formulas in a first order logic,
and call them <a class="reference internal" href="logic.html#term-local-formula"><span class="xref std std-term">local formulas</span></a>.</p>
<p>In this logic, terms can be of type <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">message</span></span></code>, <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">boolean</span></span></code>,
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">index</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span></code>.  The logic lets us prove that formulas are
true for all possible traces of the protocol, and for all possible
values of the variables given a trace.</p>
<p>For instance, a timestamp variable <cite>t</cite> allows to talk about a given
point inside a trace. <cite>t</cite> will intuitively have to take the value of
some concrete action, <em>e.g.</em>, <cite>T(i)</cite> or <cite>R(j)</cite> in our case.</p>
<section id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this heading">¶</a></h2>
<p>To discuss about the value of the output performed at some timestamp, we use macros:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;t</span></span></code> is the value given as input by the attacker to the action at <cite>t</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">output</span></span><span><span class="pre">&#64;t</span></span></code> is the output performed by the action at <cite>t</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">cond</span></span><span><span class="pre">&#64;t</span></span></code> is the executability condition of the action at <cite>t</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> is the sequence of all previous outputs up to <cite>t</cite>;</p></li>
<li><p><code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">exec</span></span><span><span class="pre">&#64;t</span></span></code> is the conjunction of all executability conditions up to <cite>t</cite>.</p></li>
</ul>
</div></blockquote>
</section>
<section id="formulas">
<h2>Formulas<a class="headerlink" href="#formulas" title="Permalink to this heading">¶</a></h2>
<p>It is then possible to write formulas that capture properties
satisfied by all executions of the protocol. For instance, the
following formula describes that the executability execution of the
reader in fact implies some authentication property. More precisely,
there must exist an action <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code> that was executed before the
reader, and such the input of the reader corresponds to the name of
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span>lemma wa :
  </span><span class="ansi-fg-light-blue">forall</span><span> (i:</span><span class="ansi-fg-light-cyan">index</span><span>, j:</span><span class="ansi-fg-light-cyan">index</span><span>),
  </span><span class="ansi-fg-light-green">happens</span><span>(R(j,i)) =&gt;
     </span><span class="ansi-fg-light-green">cond</span><span>&#64;R(j,i) =&gt;
         </span><span class="ansi-fg-light-blue">exists</span><span> (k:</span><span class="ansi-fg-light-cyan">index</span><span>),
              T(i,k) &lt;= R(j,i) &amp;&amp; fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;R(j,i)) = nT(i,k).
</span></dt><dd><span>[error&gt; [error-0-0]
Error: unknown symbol default
</span></dd>
</dl>
</div>
<p>We write below the simple proof of this statement. The high-level
idea of the proof is to use the <strong>EUF</strong> cryptographic axiom:
only the tag <cite>T(i,k)</cite> can compute <cite>h(nT(i,k),key(i))</cite> because the
secret key is not known by the attacker. Therefore, any message
accepted by the reader must come from a tag that has played before.
The converse implication is trivial, because any honest tag output is
accepted by the reader.</p>
<p>Once inside a proof context, delimited by <cite>Proof.</cite> and <cite>Qed.</cite>, it is
possible to display the list of available tactics by typing <cite>help.</cite>, and
details about any tactic with <cite>help tacticname.</cite></p>
<p>We now start the proof.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[error&gt; Cannot start a new proof (no goal remaining to prove).
</span></dd>
</dl>
</div>
<p>After the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">Proof</span></span></code> command, <strong>Squirrel</strong> displays the current
judgement. It contains the number of goals that remain to be proved
(one at first, but additional subgoals may be created by tactics), the system we are
working in, and the formula to be proved.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">intro</span><span> i j Hh Hc.
</span></dt><dd><span>[error&gt; [error-0-5]
Syntax error: at line 1 char 5 of this input before “intro”.
</span></dd>
</dl>
</div>
<p>We have performed an introduction with the <a class="reference internal" href="proofs.html#squirrel:tacn.intro" title="intro"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> tactic. This
pushes universal quantification inside the judgment context, where
the universally quantified variables become free variables. This allows us
to then push the left-hand side of the implications as hypotheses of
the judgment, that we can then reason on. The free variables and
assumptions are named according to the identifiers given as parameters to <a class="reference internal" href="proofs.html#squirrel:tacn.intro" title="intro"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">cond</span><span>.
</span></dt><dd><span>[error&gt; [error-0-6]
Syntax error: at line 1 char 6 of this input before “expand”.
</span></dd>
</dl>
</div>
<p>After introducing the hypotheses and expanding the executability
condition of <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R</span></span></code>, we get an equality between a hash and some other
term <code class="squirrelinline docutils literal notranslate"><span><span class="pre">snd</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code>. We then use the unforgeability of the
hash function, the <strong>EUF</strong> assumption, to get that the hashed value
<code class="squirrelinline docutils literal notranslate"><span><span class="pre">fst</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code> must be equal to some honestly hashed value
in <code class="squirrelinline docutils literal notranslate"><span><span class="pre">snd</span> <span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R(j,</span> <span class="pre">i))</span></span></code>, since the key <code class="squirrelinline docutils literal notranslate"><span><span class="pre">key</span></span></code> is secret. All
honestly hashes are produced by the tag, which will then conclude our
proof. This cryptographic axiom is applied thanks to the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a>
tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Hc.
</span></dt><dd><span>[error&gt; [error-0-3]
Syntax error: at line 1 char 3 of this input before “euf”.
</span></dd>
</dl>
</div>
<p>To conclude, we just have to use the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> introduced by the
<a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a> tactic as a witness for the existential <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k</span></span></code> we have to
find.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">intro</span><span> [k _].
</span></dt><dd><span>[error&gt; [error-0-5]
Syntax error: at line 1 char 5 of this input before “intro”.
</span></dd>
<dt><span>  </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> k.
</span></dt><dd><span>[error&gt; [error-0-2]
Syntax error: at line 1 char 2 of this input before “by”.
</span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span>[error&gt; [error-0-4]
Syntax error: at line 1 char 4 of this input before “Qed.”.
</span></dd>
</dl>
</div>
</section>
</section>
<section id="equivalence-properties">
<h1>Equivalence properties<a class="headerlink" href="#equivalence-properties" title="Permalink to this heading">¶</a></h1>
<p>More complex properties based on equivalence can be
expressed. Intuitively, two processes are equivalent if the attacker
cannot know whether it is interacting with one or the other. This is a
generic security property used in the computational model to prove
many distinct flavours of security.</p>
<p>We can declare in <strong>Squirrel</strong> two variants of a protocol at once using
the <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">diff</span></span><span><span class="pre">(t1,t2)</span></span></code> operator. A process containing diff-terms is
called a bi-process, as it can lead to two distinct processes when
projecting on the left or the right of the diff. This allows to easily
model some security properties.</p>
<p>For instance, we can declare a bi-process <code class="squirrelinline docutils literal notranslate"><span><span class="pre">tagD</span></span></code>, where
on one side each tag may be called many times and always use
there own key, while on the right side, we in
fact use a new fresh independent key every time a tag is called.
The left-hand side of the process can be seen as the real world,
while the right-hand side is an idealised world where a new tag is used each time.
Proving that these two worlds are equivalent will establish
that tags cannot be tracked.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">name</span><span> key’: </span><span class="ansi-fg-light-cyan">index</span><span> * </span><span class="ansi-fg-light-cyan">index</span><span> -&gt; </span><span class="ansi-fg-light-cyan">message</span><span>

</span><span class="ansi-fg-light-blue">process</span><span> tagD(i:</span><span class="ansi-fg-light-cyan">index</span><span>,k:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">new</span><span> nT;
  </span><span class="ansi-fg-light-blue">out</span><span>(cT, &lt;nT, h(nT,</span><span class="ansi-fg-light-green">diff</span><span>(key(i),key’(i,k)))&gt;).
</span></dt><dd><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_key’ :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
</span><span class="ansi-bold ansi-fg-blue">process</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tagD (i,k:index) =
   </span><span class="ansi-bold">new</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> : message; </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,&lt;nT,</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (nT, diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))&gt;); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span></dd>
<dt><span class="ansi-fg-light-blue">process</span><span> readerD(j:</span><span class="ansi-fg-light-cyan">index</span><span>) =
  </span><span class="ansi-fg-light-blue">in</span><span>(cT,x);
  </span><span class="ansi-fg-light-blue">if</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>), snd(x) = h(fst(x),</span><span class="ansi-fg-light-green">diff</span><span>(key(i),key’(i,k))) </span><span class="ansi-fg-light-blue">then</span><span>
    </span><span class="ansi-fg-light-blue">out</span><span>(cR,ok)
  </span><span class="ansi-fg-light-blue">else</span><span>
    </span><span class="ansi-fg-light-blue">out</span><span>(cR,ko)

</span><span class="ansi-fg-light-blue">system</span><span> [BasicHash] ((!_j R: readerD(j)) | (!_i !_k T: tagD(i,k))).
</span></dt><dd><span class="ansi-bold ansi-fg-blue">process</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> readerD (j:index) =
   </span><span class="ansi-bold">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold ansi-fg-magenta">x</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">);
   </span><span class="ansi-underline ansi-fg-red">if</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> exists (i,k:index), </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> x </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> x, diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))) </span><span class="ansi-underline ansi-fg-red">then</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
   </span><span class="ansi-underline ansi-fg-red">else</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span>Typed-check process:
  
   ( !_j( R: </span><span class="ansi-bold ansi-fg-blue">readerD</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> j) ) | !_i( !_k( T: </span><span class="ansi-bold ansi-fg-blue">tagD</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i k))
</span><span>
</span><span>global </span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [any] namelength_nT :
  [forall (i:index * index), </span><span class="ansi-bold">len</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">namelength_message</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">]
Added action dependencies lemmas:

</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] mutex_BasicHash_R1_R :
  forall (j:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] mutex_BasicHash_R_R1 :
  forall (j:index), </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">||</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">not</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] depends_BasicHash_init_T :
  forall (t:timestamp,i,k:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] depends_BasicHash_init_R1 :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R1(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
</span><span class="ansi-fg-red">axiom</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] depends_BasicHash_init_R :
  forall (t:timestamp,j:index), t </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">

System after processing:
  
   ( !_j(
       </span><span class="ansi-bold">in</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold ansi-fg-magenta">x</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">);
       </span><span class="ansi-underline ansi-fg-red">if</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> exists (i,k:index), </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> x </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> x, diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))) </span><span class="ansi-underline ansi-fg-red">then</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
         R: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
       </span><span class="ansi-underline ansi-fg-red">else</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
         R1: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcR</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,</span><span class="ansi-bold">ko</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) ) |
   !_i(
     !_k(
       T: </span><span class="ansi-bold">out</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">([mcT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">,&lt;</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))&gt;); </span><span class="ansi-bold ansi-fg-blue">null</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span>
</span><span>System BasicHash registered with actions (init,R,R1,T).
</span><span>System Empty registered with actions (init).
</span></dd>
</dl>
</div>
<p>Importantly, reachability formulas can be expressed and proved
directly on bi-systems. We can for instance write a variant of the
previous proof directly on the bi-system:</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span>lemma [BasicHash] wa_R :
  </span><span class="ansi-fg-light-blue">forall</span><span> (tau:</span><span class="ansi-fg-light-cyan">timestamp</span><span>),
    </span><span class="ansi-fg-light-green">happens</span><span>(tau) =&gt;
    ((</span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>),
       snd(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau) = h(fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau),</span><span class="ansi-fg-light-green">diff</span><span>(key(i),key’(i,k))))
     &lt;=&gt;
     (</span><span class="ansi-fg-light-blue">exists</span><span> (i,k:</span><span class="ansi-fg-light-cyan">index</span><span>), T(i,k) &lt; tau &amp;&amp;
       fst(</span><span class="ansi-fg-light-green">output</span><span>&#64;T(i,k)) = fst(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau) &amp;&amp;
       snd(</span><span class="ansi-fg-light-green">output</span><span>&#64;T(i,k)) = snd(</span><span class="ansi-fg-light-green">input</span><span>&#64;tau))).
</span></dt><dd><span>Goal wa_R :
  forall (tau:timestamp),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    (exists (i,k:index),
       </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (i,k:index),
      </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
</span></dd>
</dl>
</div>
<p>The idea of the proof is similar, except that we prove here a
logical equivalence instead of an implication.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: BasicHash
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
forall (tau:timestamp),
  </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  (exists (i,k:index),
     </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  exists (i,k:index),
    </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span>  </span><span class="ansi-fg-light-blue">intro</span><span> tau Hap.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: BasicHash
Variables: tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(exists (i,k:index),
   </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>We have to prove two implications (<code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;=&gt;</span></span></code>): we thus split the proof
in two parts. We now have two different goals to prove.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> [i k Meq].
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
System: BasicHash
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>For the first implication (<code class="squirrelinline docutils literal notranslate"><span><span class="pre">=&gt;</span></span></code>), we actually consider separately
the real system (left) and the ideal system (right).</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">project</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>The proof is very similar on both sides, and relies on the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a>
tactic.  Applying the <a class="reference internal" href="proofs.html#squirrel:tact.euf" title="euf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">euf</span></code></a> tactic on the <cite>Meq</cite> hypothesis
generates a new hypothesis stating that <cite>fst(input&#64;R(j))</cite> must be
equal to some message that has already been hashed before.  The only
possibility is that this hash comes from the output of a tag that has
played before (thus the new hypothesis on timestamps).</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Meq.
</span></dt><dd><span>Indirect bad occurrences of key key(i), and messages authenticated by it 
in other actions:
  </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) auth. by key(i) 
    (collision with </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) auth. by key(i))
    in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    in term &lt;</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)&gt;

Total: 1 occurrence
       0 of them are subsumed by another
       1 occurrence remaining
       
[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
(exists (k:index), </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">intro</span><span> [k0 _].
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
System: left:BasicHash/left
Variables: i,k,k0:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i)
_: </span><span class="ansi-fg-green">T(i, k0)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k0)
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k0.
</span></dt><dd><span>[goal&gt; Focused goal (1/2):
System: right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
</dl>
</div>
<p>The right side of the proof is very similar.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">euf</span><span> Meq =&gt; *.
</span></dt><dd><span>Indirect bad occurrences of key key’((i, k)),
         and messages authenticated by it 
in other actions:
  </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k) auth. by key’((i, k)) 
    (collision with </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) auth. by key’((i, k)))
    in action </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    in term &lt;</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k),</span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k), </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))&gt;

Total: 1 occurrence
       0 of them are subsumed by another
       1 occurrence remaining
       
[goal&gt; Focused goal (1/2):
System: right:BasicHash/right
Variables: i,k:index[const],tau:timestamp[const]
H: </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-fg-yellow">nT</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)

</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
System: BasicHash
Variables: i,k:index[const],tau:timestamp[const]
Hap: </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau)
Meq: </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
     </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
exists (i,k:index),
  </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))

</span><span>
</span></dd>
</dl>
</div>
<p>We use here the notation <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span><span> <span class="pre">Meq</span> <span class="pre">=&gt;</span> <span class="pre">*</span></span></code>, which is a shortcut for
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">euf</span></span><span> <span class="pre">Meq;</span> </span><span class="ansi-fg-light-blue"><span class="pre">intro</span></span><span> <span class="pre">*</span></span></code>, the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">*</span></span></code> performing as many introductions
as possible, with automatic naming of variables and hypotheses.</p>
<p>For the second implication (<code class="squirrelinline docutils literal notranslate"><span><span class="pre">&lt;=</span></span></code>), the conclusion of the goal can
directly be obtained from the hypotheses.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">exists</span><span> i,k.
</span></dt><dd><span>[goal&gt; lemma wa_R is proved
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span class="ansi-fg-red">lemma</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> [BasicHash] wa_R :
  forall (tau:timestamp),
    </span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(tau) </span><span class="ansi-bold">=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    (exists (i,k:index),
       </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">h</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau), diff(</span><span class="ansi-fg-yellow">key</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> i, </span><span class="ansi-fg-yellow">key’</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (i, k)))) </span><span class="ansi-bold">&lt;=&gt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
    exists (i,k:index),
      </span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">&lt;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> tau </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">fst</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
      </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">output</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">T(i, k)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">=</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold">snd</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">input</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;tau)
Exiting proof mode.
</span><span>
</span></dd>
</dl>
</div>
<p>We now prove an equivalence property expressing the unlinkability of the
protocol. This property is expressed by the logical formula <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">forall</span></span><span>
<span class="pre">t:</span></span><span class="ansi-fg-light-cyan"><span class="pre">timestamp</span></span><span><span class="pre">,</span> <span class="pre">[</span></span><span class="ansi-fg-light-green"><span class="pre">happens</span></span><span><span class="pre">(t)]</span> <span class="pre">-&gt;</span> </span><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span><span><span class="pre">(</span></span><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t)</span></span></code> where <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> is
actually a bi-frame. It states that for any trace (the quantification
is implicit over all traces), at any point that happens in the trace,
the two frames (derived by projecting the diff operator) are equivalent. Square
brackets contain local formulas, and such a formula mixing both local
formulas and equivalences is called a <a class="reference internal" href="logic.html#term-global-formula"><span class="xref std std-term">global formula</span></a>.</p>
<p>Here, we will have to prove that the left projection of <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> (<em>i.e.</em>
the real system) is indistinguishable from the right projection of
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;t</span></span></code> (<em>i.e.</em> the ideal system).</p>
<p>As this goal is a frequent one, a shortcut allows declaring this goal
without writing the full formula, using the keyword <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-blue"><span class="pre">equiv</span></span></code>.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">equiv</span><span> [BasicHash] unlinkability.
</span></dt><dd><span>Goal unlinkability :
  forall t:timestamp[const, glob], equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;t)
</span></dd>
<dt><span class="ansi-fg-light-blue">Proof</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/1):
Systems: BasicHash (same for equivalences)
Variables: t:timestamp[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(t)]
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;t
 
</span><span>
</span></dd>
</dl>
</div>
<p>An equivalence judgment contains the list of hypotheses, as
before. The conclusion is however different to the reachability
case. Now, we have a numbered list of diff-terms, and we must prove that
the left projection and the right projection of this list are
indistinguishable. We refer to this sequence of diff terms as the
biframe of the goal.</p>
<p>The high-level idea of the proof is as follows:</p>
<ul class="simple">
<li><p>if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> corresponds to a reader’s action, we show that the outcome of the
conditional is the same on both sides and that this outcome only depends
on information already available to the attacker;</p></li>
<li><p>if <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code> corresponds to a tag’s action, we show that the new message added
in the frame (<em>i.e.</em> the tag’s output) does not give any information
that helps the attacker distinguish the real system from the ideal one.
Indeed, hashes can intuitively be seen as fresh names thanks to the <strong>PRF</strong>
cryptographic axiom.</p></li>
</ul>
<p>The proof is done by induction over the timestamp <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.  The
<a class="reference internal" href="proofs.html#squirrel:tacn.induction" title="induction"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic also automatically introduces a case analysis over
all possible values for <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span></span></code>.  The first case, where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span>
<span class="pre">init</span></span></code> corresponds to the initial point of the execution trace, before
any protocol action has happened. That case is trivial, we directly close it with
<a class="reference internal" href="proofs.html#squirrel:tacn.auto" title="auto"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>.  The other cases correspond to the 3 different actions
of the protocol.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">induction</span><span> t.
</span></dt><dd><span>[goal&gt; Focused goal (1/4):
Systems: BasicHash (same for equivalences)
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">init</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">auto</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: BasicHash (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>For the case where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">R2(j)</span></span></code>, we start by expanding the macros
and splitting the pairs. Splitting the pairs is done by using the
<a class="reference internal" href="proofs.html#squirrel:tacn.fa" title="fa"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fa</span></code></a> tactic, which when applied to all pairs thanks to the
pattern <code class="squirrelinline docutils literal notranslate"><span><span class="pre">!&lt;_,_&gt;</span></span></code> splits a bi-frame element containing a pair into
two biframe elements, containing the the two components.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: BasicHash (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: &lt;</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
    &lt;</span><span class="ansi-bold">of_bool</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">),
     if (</span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) then </span><span class="ansi-bold">ok</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&gt;&gt;
 
</span><span>
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;.
</span></dt><dd><span>[goal&gt; Focused goal (1/3):
Systems: BasicHash (same for equivalences)
Variables: j:index[const, glob]
H: [</span><span class="ansi-bold ansi-fg-magenta">happens</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">(</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)]
IH: equiv(</span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">))
</span><span class="ansi-bold">—————————————-</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
0: </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
1: </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">
 
</span><span>
</span></dd>
</dl>
</div>
<p>Using the previously proved authentication goal <code class="squirrelinline docutils literal notranslate"><span><span class="pre">wa_R</span></span></code>, we replace
the formula <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">cond</span></span><span><span class="pre">&#64;R2(j)</span></span></code> with an equivalent formula, which states
that a tag <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i,k)</span></span></code> has played before and that the output of
this tag is equal to the message input by the reader. This is one of the
strength of <strong>Squirrel</strong>: we can finely reuse previously proved goals to
simplify a current goal. Here, we can see the <code class="squirrelinline docutils literal notranslate"><span><span class="pre">wa_R</span></span></code> lemma as a
rewriting rule over boolean formulas, and so we use the <a class="reference internal" href="proofs.html#squirrel:tacn.rewrite" title="rewrite"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>
tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">rewrite</span><span> /</span><span class="ansi-fg-light-green">cond</span><span> (wa_R (R2 j)) //.
</span></dt><dd><span>[error&gt; [error-21-23]
Error: unknown symbol R2
</span></dd>
</dl>
</div>
<p>We are now able to remove this formula from the frame because the
attacker is able to compute it using information obtained in the
past. Indeed, each of its elements is already available in
<code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">frame</span></span><span><span class="pre">&#64;pred(R2(j))</span></span></code>. This is done by the <a class="reference internal" href="proofs.html#squirrel:tace.deduce" title="deduce"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">deduce</span></code></a> tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">deduce</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>[error&gt; [error-3-9]
Tactic failed: apply failed: no match found:
  </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
  </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bg-red"></span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span><span>
</span></dd>
</dl>
</div>
<p>The case where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">R1(j)</span></span></code> is similar to the previous one.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[error&gt; [error-7-12]
Tactic failed: nothing to expand
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;.
</span></dt><dd><span>[error&gt; [error-4-9]
Tactic failed: FA not applicable
</span></dd>
<dt><span class="ansi-fg-light-blue">rewrite</span><span> /</span><span class="ansi-fg-light-green">cond</span><span> (wa_R (R1 j)) //.
</span></dt><dd><span>[error&gt; [error-14-27]
Tactic failed: nothing to rewrite
</span></dd>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">deduce</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>[error&gt; [error-3-9]
Tactic failed: apply failed: no match found:
  </span><span class="ansi-bold ansi-fg-magenta">frame</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">)
  </span><span class="ansi-bold ansi-fg-magenta">exec</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-bold">pred</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> (</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">) </span><span class="ansi-bold">&amp;&amp;</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"> </span><span class="ansi-bg-red"></span><span class="ansi-bold ansi-fg-magenta">cond</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default">&#64;</span><span class="ansi-fg-green">R(j)</span><span class="ansi-no-bold ansi-no-underline ansi-fg-default"></span><span>
</span></dd>
</dl>
</div>
<p>Finally, for the case where <code class="squirrelinline docutils literal notranslate"><span><span class="pre">t</span> <span class="pre">=</span> <span class="pre">T(i,k)</span></span></code>, we similarly start by expanding the
macros and splitting the pairs.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">expand</span><span> </span><span class="ansi-fg-light-green">frame</span><span>, </span><span class="ansi-fg-light-green">exec</span><span>, </span><span class="ansi-fg-light-green">cond</span><span>, </span><span class="ansi-fg-light-green">output</span><span>.
</span></dt><dd><span>[error&gt; [error-7-12]
Tactic failed: nothing to expand
</span></dd>
<dt><span class="ansi-fg-light-blue">fa</span><span> !&lt;_,_&gt;, </span><span class="ansi-fg-light-blue">if</span><span> _ </span><span class="ansi-fg-light-blue">then</span><span> _, &lt;_,_&gt;.
</span></dt><dd><span>[error&gt; [error-4-9]
Tactic failed: FA not applicable
</span></dd>
</dl>
</div>
<p>We now apply the <a class="reference internal" href="proofs.html#squirrel:tace.prf" title="prf"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">prf</span></code></a> tactic, in order to replace the hash with a fresh
name. This creates a new subgoal, asking to prove that the hashed value
has never been hased before.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">prf</span><span> </span><span class="ansi-fg-light-blue">2</span><span>.
</span></dt><dd><span>[error&gt; [error-4-5]
Tactic failed: out of range position
</span></dd>
</dl>
</div>
<p>Several conjuncts must now be proved, the same tactic can be used on
all of them. Here are a few representative cases:</p>
<blockquote>
<div><ul class="simple">
<li><p>In one case, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span></span></code> cannot occur in <code class="squirrelinline docutils literal notranslate"><span class="ansi-fg-light-green"><span class="pre">input</span></span><span><span class="pre">&#64;R2(j)</span></span></code>
because <code class="squirrelinline docutils literal notranslate"><span><span class="pre">R2(j)</span> <span class="pre">&lt;</span> <span class="pre">T(i,k)</span></span></code>.</p></li>
<li><p>In another case, <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span> <span class="pre">=</span> <span class="pre">nT(i0,k0)</span></span></code> implies that <code class="squirrelinline docutils literal notranslate"><span><span class="pre">i=i0</span></span></code> and <code class="squirrelinline docutils literal notranslate"><span><span class="pre">k=k0</span></span></code>,
contradicting <code class="squirrelinline docutils literal notranslate"><span><span class="pre">T(i0,k0)&lt;T(i,k)</span></span></code>.</p></li>
</ul>
</div></blockquote>
<p>In both cases, the reasoning is performed by the <a class="reference internal" href="proofs.html#squirrel:tacn.fresh" title="fresh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> tactic on the
message equality hypothesis <code class="squirrelinline docutils literal notranslate"><span><span class="pre">Meq</span></span></code>, whose negation was initially to be
proved. To be able to use (<a class="reference internal" href="proofs.html#squirrel:tacn.split" title="split"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">split</span></code></a> and) <a class="reference internal" href="proofs.html#squirrel:tacn.fresh" title="fresh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a>, we first project the
goal onto on the left projection and one goal for the right projection of the initial bi-system.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">repeat</span><span> </span><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> *; </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> Meq.
</span></dt><dd><span>[error&gt; [error-26-31]
Tactic ill-formed or unapplicable: improper arguments
</span></dd>
<dt><span class="ansi-fg-light-blue">repeat</span><span> </span><span class="ansi-fg-light-blue">split</span><span>; </span><span class="ansi-fg-light-blue">intro</span><span> *; </span><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> Meq.
</span></dt><dd><span>[error&gt; [error-26-31]
Tactic ill-formed or unapplicable: improper arguments
</span></dd>
</dl>
</div>
<p>We have now replaced the hash by a fresh name occurring nowhere else,
so we can remove it using the <a class="reference internal" href="proofs.html#squirrel:tacn.fresh" title="fresh"><code class="xref squirrel squirrel-tacn docutils literal notranslate"><span class="pre">fresh</span></code></a> tactic.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">fresh</span><span> </span><span class="ansi-fg-light-blue">2</span><span>; </span><span class="ansi-fg-light-blue">1</span><span>:</span><span class="ansi-fg-light-blue">auto</span><span>.
</span></dt><dd><span>[error&gt; [error-6-7]
Tactic failed: out of range position
</span></dd>
</dl>
</div>
<p>We can also remove the name <code class="squirrelinline docutils literal notranslate"><span><span class="pre">nT(i,k)</span></span></code>, and conclude (automatically) by the induction
hypothesis.</p>
<div class="squirreltop literal-block docutils container">
<span></span><dl>
<dt><span class="ansi-fg-light-blue">by</span><span> </span><span class="ansi-fg-light-blue">fresh</span><span> </span><span class="ansi-fg-light-blue">1</span><span>.
</span></dt><dd><span>Freshness on the left side:
 [error&gt; [error-9-10]
 Tactic failed: Can only be applied to diff(n_L, n_R).
 </span></dd>
<dt><span class="ansi-fg-light-blue">Qed</span><span>.
</span></dt><dd><span>[error&gt; Unexpected command.
</span></dd>
</dl>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="commands.html" class="btn btn-neutral float-left" title="Commands" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="appendix/indexes/index.html" class="btn btn-neutral float-right" title="Indexes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Squirrel developpers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>